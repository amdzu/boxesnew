<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drag and Drop Learning Tool</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
      background-color: #fff;
    }

    .menu {
      position: absolute;
      top: 20px;
      right: 20px;
    }

    .menu-button {
      width: 60px;
      height: 45px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: pointer;
    }

    .menu-button span {
      height: 4px;
      background-color: #fff;
      border-radius: 2px;
    }

    .menu-content {
      display: none;
      position: absolute;
      right: 0;
      top: 35px;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0px 2px 8px rgba(0,0,0,0.15);
      padding: 10px;
      z-index: 100;
    }

    .menu-content a {
      display: block;
      text-decoration: none;
      color: #333;
      padding: 5px 0;
      cursor: pointer;
    }

    :root {
      --square-size: 40px;
      --sentence-width: 190px;
      --sentence-height: 65px;
      --sentence-arm-width: 40px;
      --sentence-arm-height: 40px;
      --sentence-default-color: #2ecc71;
      --sentence-radius: 6px;
      --slot-gap: 10px;
    }

    .container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 50px;
      margin-bottom: 50px;
      flex-wrap: wrap;
    }

    #topContainer {
      align-items: flex-end;
    }

    .square {
      width: var(--square-size);
      height: var(--square-size);
      cursor: grab;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: white;
      font-weight: bold;
      position: relative;
      touch-action: none;
      border-radius: 6px;
      }

    .large-circle {
      width: var(--square-size);
      height: var(--square-size);
      cursor: grab;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: white;
      font-weight: bold;
      position: relative;
      touch-action: none;
      border-radius: 50%;
    }

    /* L-shaped sentence token inspired by form.png */
    .sentence,
    .dropped-sentence {
      width: var(--sentence-width);
      height: var(--sentence-height);
      background-color: var(--sentence-default-color);
      clip-path: polygon(
        0 0,
        calc(var(--sentence-arm-width) / var(--sentence-width) * 100%) 0,
        calc(var(--sentence-arm-width) / var(--sentence-width) * 100%)
          calc((var(--sentence-height) - var(--square-size)) / var(--sentence-height) * 100%),
        100% calc((var(--sentence-height) - var(--square-size))/ var(--sentence-height) * 100%),
        100% 100%,
        0 100%
      );
      border-radius: var(--sentence-radius);
      color: #4d3b02;
      font-weight: 600;
      font-size: 20px;
      padding: 8px;
      box-sizing: border-box;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      text-align: left;
    }

    .sentence {
      cursor: grab;
      position: relative;
      touch-action: none;
    }

    .dropped-sentence {
      position: absolute;
      bottom: 0;
      left: 0;
      cursor: move;
      z-index: 3;
    }

    .mark,
    .dropped-mark {
      width: var(--square-size);
      height: var(--sentence-height);
      position: relative;
      cursor: grab;
      touch-action: none;
      display: flex;
      align-items: flex-start;
      justify-content: center;

    
    }

    .dropped-mark {
      cursor: move;
      position: absolute;
      bottom: 0;
      left: 0;
      z-index: 3;
    }

    .mark span,
    .dropped-mark span {
      position: absolute;
      bottom: -0.08em;
      width: 100%;
      text-align: center;
      font-size: calc(var(--sentence-height) * 0.9);
      font-weight: 600;
      font-family: 'Trebuchet MS', 'Segoe UI', sans-serif;
      line-height: 1;
      color: inherit;
    }


    .draggable-shape input {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      color: inherit;
      font-weight: inherit;
      font-size: inherit;
      text-align: inherit;
    }

    .delete-btn {
      position: absolute;
      top: 2px;
      right: 4px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      text-align: center;
      line-height: 14px;
      cursor: pointer;
      display: none;
      z-index: 10;
    }

    .square:hover .delete-btn,
    .sentence:hover .delete-btn {
      display: block;
    }

    .red { background-color: #d7263d; }
    .blue { background-color: #276bd7; }
    .purple { background-color: #6c2ed7; }
    .green { background-color: #2ecc71; }
    .brown { background-color: #8b5e3c; }
    .turquoise { background-color: #1abc9c; }

    .drop-zone {
      width: 1200px;
      height: 100px;
      margin: 0 auto;
      display: flex;
      justify-content: flex-start;
      align-items: flex-end;
      align-content: flex-start;
      background-color: #f9f9f9;
      padding: 10px;
      box-sizing: border-box;
      flex-wrap: wrap;
      gap: var(--slot-gap);
    }

    .slot {
      width: var(--square-size);
      height: var(--square-size);
      position: relative;
      flex-shrink: 0;
      touch-action: none;
      transform: translateY(35px);
    }

    .slot.highlighted {
      border: 2px dashed lightgrey;
    }



    .dropped-shape {
      position: absolute;
      bottom: 0;
      left: 0;
      cursor: move;
      display: flex;
      font-weight: bold;
      box-sizing: border-box;
      transform-origin: bottom left;
      z-index: 2;
    }

    .dropped-square {
      width: var(--square-size);
      height: var(--square-size);
      border-radius: 6px;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: white;
      text-align: center;
    }

    .dropped-large-circle {
      width: var(--square-size);
      height: var(--square-size);
      border-radius: 50%;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: white;
      text-align: center;
    }

    #colorSelector {
      display:none;
      position:absolute;
      top:70px;
      right:20px;
      background:#fff;
      border:1px solid #ccc;
      padding:10px;
      z-index:100;
    }





.circle {
  width: 15px;
  height: 15px;
  background-color: #FFD700;
  border-radius: 50%;
  position: absolute;
  cursor: grab;
  z-index: 50;
  pointer-events: auto;
}


.selected {
  outline: 3px solid orange;
  outline-offset: -3px;
  animation: pulse 1s infinite alternate;
}

.selected {
  outline: 3px solid #FFD700;
  box-shadow: 0 0 10px #FFD700;
}


@keyframes pulse {
  from { outline-color: orange; }
  to { outline-color: gold; }
}




  </style>
</head>
<body>
  <!-- Menu -->
  <div class="menu">
    <div class="menu-button" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </div>
    <div class="menu-content" id="menuContent">
      <a href="#" id="editButton">Edit</a>
      <a href="#" id="addSquareButton">Add</a>
    </div>
  </div>

  <!-- Color selector -->
  <div id="colorSelector">
    <label for="shapeChoice">Tile Type:</label>
    <select id="shapeChoice">
      <option value="square">Square</option>
      <option value="sentence">Sentence</option>
      <option value="large-circle">Large Circle</option>
      <option value="exclamation">Exclamation</option>
      <option value="question">Question</option>
      <option value="period">Period</option>
      <option value="comma">Comma</option>
      <option value="colon">Colon</option>
      <option value="semicolon">Semicolon</option>
      <option value="quote">Quotation Mark</option>
      <option value="apostrophe">Apostrophe</option>
    </select>
    <label for="colorChoice">Color:</label>
    <select id="colorChoice">
      <option value="red">Red</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="green">Green</option>
      <option value="brown">Brown</option>
      <option value="turquoise">Turquoise</option>
      <option value="orange">Orange</option>
      <option value="yellow">Yellow</option>
      <option value="pink">Pink</option>
      <option value="black">Black</option>
      <option value="gray">Gray</option>
      <option value="cyan">Cyan</option>
      <option value="lime">Lime</option>
      <option value="navy">Navy</option>
      <option value="teal">Teal</option>
      <option value="magenta">Magenta</option>
    </select>
    <button onclick="addNewTile()">Add Tile</button>
  </div>

  <!-- Draggable squares -->
  <div class="container" id="topContainer"></div>

  <!-- Drop zone with slots -->
  <div class="drop-zone" id="dropZone"></div>

<div style="height: 50px;"></div>




<div class="container">
<div class="circle" draggable="true" data-original="true" data-id="circle-1"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-2"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-3"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-4"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-5"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-6"></div>

<div class="circle" draggable="true" data-original="true" data-id="circle-7"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-8"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-9"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-10"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-11"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-12"></div>

<div class="circle" draggable="true" data-original="true" data-id="circle-13"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-14"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-15"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-16"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-17"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-18"></div>




</div>






  <!-- ‚ú® Audio -->
  <audio id="dropSound" src="drop.mp3"></audio>
  <audio id="deleteSound" src="delete.mp3"></audio>

  <script>

    let selectedElement = null;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);


    let editMode = false;
    let currentDragShape = null;
    const dropZone = document.getElementById('dropZone');
    const topContainer = document.getElementById('topContainer');
    const dropSound = document.getElementById('dropSound');
    const deleteSound = document.getElementById('deleteSound');
    const TILE_COLORS = {
      red: '#d7263d',
      blue: '#276bd7',
      purple: '#6c2ed7',
      green: '#2ecc71',
      brown: '#8b5e3c',
      turquoise: '#1abc9c',
      sentence: '#ffe085',
      orange: '#f39c12',
      yellow: '#f1c40f',
      pink: '#ff69b4',
      black: '#333333',
      gray: '#95a5a6',
      cyan: '#00bcd4',
      lime: '#9acd32',
      navy: '#001f3f',
      teal: '#008080',
      magenta: '#d81b60',
    };
    const MULTI_SLOT_SHAPES = new Set(['sentence']);
    const MARK_SHAPES = new Set([
      'exclamation',
      'question',
      'period',
      'comma',
      'colon',
      'semicolon',
      'quote',
      'apostrophe',
    ]);
    const MARK_SYMBOLS = {
      exclamation: '!',
      question: '?',
      period: '.',
      comma: ',',
      colon: ':',
      semicolon: ';',
      quote: '"',
      apostrophe: "'",
    };
    const rootStyles = getComputedStyle(document.documentElement);
    const BASE_TILE_SIZE = parseInt(rootStyles.getPropertyValue('--square-size')) || 80;
    const SLOT_GAP = parseInt(rootStyles.getPropertyValue('--slot-gap')) || 10;
    const SENTENCE_WIDTH = parseFloat(rootStyles.getPropertyValue('--sentence-width')) || BASE_TILE_SIZE;
    const SENTENCE_SLOT_SPAN = Math.max(1, Math.round((SENTENCE_WIDTH + SLOT_GAP) / (BASE_TILE_SIZE + SLOT_GAP)));
    const CIRCLE_SIZE = Math.max(6, Math.round(BASE_TILE_SIZE * 0.375));
    const CIRCLE_GAP = Math.max(2, Math.round(BASE_TILE_SIZE * 0.125));
    const dropZoneWidth = dropZone.clientWidth || 1200;
    const SLOT_COUNT = Math.max(SENTENCE_SLOT_SPAN, Math.floor(dropZoneWidth / (BASE_TILE_SIZE + SLOT_GAP)));
    const slots = [];
    let highlightedSlotEls = [];

    function getMarkSymbol(shape) {
      return MARK_SYMBOLS[shape] || '';
    }

    function layoutSlotCircles(slotEl) {
      if (!slotEl) return;
      const circles = Array.from(slotEl.querySelectorAll('.circle'));
      const circleSize = CIRCLE_SIZE;
      const gap = CIRCLE_GAP;
      if (!circles.length) return;
      const slotHeight = slotEl.clientHeight || slotEl.offsetHeight;
      const slotWidth = slotEl.clientWidth || slotEl.offsetWidth;
      const top = (slotHeight - circleSize) / 2;
      if (circles.length === 1) {
        const left = (slotWidth - circleSize) / 2;
        circles[0].style.top = `${top}px`;
        circles[0].style.left = `${left}px`;
        return;
      }
      const totalWidth = circleSize * 2 + gap;
      const firstLeft = (slotWidth - totalWidth) / 2;
      circles.slice(0, 2).forEach((circle, idx) => {
        circle.style.top = `${top}px`;
        circle.style.left = `${firstLeft + idx * (circleSize + gap)}px`;
      });
      circles.slice(2).forEach(circle => circle.remove());
    }

    function resolveTileColor(key) {
      return TILE_COLORS[key] || key || '#777';
    }

    function clearSlotHighlights() {
      if (!highlightedSlotEls.length) return;
      highlightedSlotEls.forEach(slotEl => {
        if (slotEl) slotEl.classList.remove('highlighted');
      });
      highlightedSlotEls = [];
    }

    function highlightSlotsFrom(startIndex, span) {
      clearSlotHighlights();
      if (Number.isNaN(startIndex)) return;
      for (let i = 0; i < span; i++) {
        const slotEl = slots[startIndex + i];
        if (!slotEl) break;
        slotEl.classList.add('highlighted');
        highlightedSlotEls.push(slotEl);
      }
    }

    function registerDraggableShape(element) {
      element.classList.add('draggable-shape');

      element.addEventListener('click', () => {
        const shapeType = element.dataset.shape || 'square';
        selectedElement = {
          type: shapeType,
          color: element.dataset.color,
          text: element.dataset.text || element.textContent || '',
        };

        document.querySelectorAll('#topContainer .draggable-shape').forEach(sq => sq.classList.remove('selected'));
        element.classList.add('selected');
        clearSlotHighlights();
      });

      if (MULTI_SLOT_SHAPES.has(element.dataset.shape || 'square')) {
        element.style.backgroundColor = resolveTileColor(element.dataset.color || 'sentence');
        element.style.color = '#4d3b02';
      } else if (MARK_SHAPES.has(element.dataset.shape || '')) {
        element.classList.add('mark', element.dataset.shape);
        const symbol = getMarkSymbol(element.dataset.shape);
        element.dataset.text = symbol;
        let span = element.querySelector('span');
        if (!span) {
          span = document.createElement('span');
          element.textContent = '';
          element.appendChild(span);
        }
        span.textContent = symbol;
        element.style.color = resolveTileColor(element.dataset.color || '#111');
      }

      element.addEventListener('dragstart', (e) => {
        const shapeType = element.dataset.shape || 'square';
        const text = element.dataset.text || element.textContent || '';
        currentDragShape = { shape: shapeType };
        applyDragPreview(element, e);
        e.dataTransfer.setData('color', element.dataset.color || '');
        e.dataTransfer.setData('text', text);
        e.dataTransfer.setData('shape', shapeType);
        e.dataTransfer.setData('source-slot', '');
      });
    }

    document.addEventListener('click', (e) => {
      if (!e.target.closest('.draggable-shape input') && !e.target.closest('#editButton')) {
        disableEditMode();
      };
    });

    document.getElementById('editButton').addEventListener('click', (e) => {
      e.preventDefault();
      enableEditMode();
    });

    document.getElementById('addSquareButton').addEventListener('click', (e) => {
      e.preventDefault();
      const selector = document.getElementById('colorSelector');
      selector.style.display = selector.style.display === 'block' ? 'none' : 'block';
    });

    document.addEventListener('click', (e) => {
      const selector = document.getElementById('colorSelector');
      const trigger = document.getElementById('addSquareButton');
      if (
        selector &&
        selector.style.display === 'block' &&
        !selector.contains(e.target) &&
        (!trigger || !trigger.contains(e.target))
      ) {
        selector.style.display = 'none';
      }
    });

    document.querySelectorAll('#topContainer .draggable-shape').forEach(registerDraggableShape);

    function addNewTile() {
      const color = document.getElementById('colorChoice').value;
      const shape = document.getElementById('shapeChoice').value;
      const tile = document.createElement('div');
      tile.setAttribute('draggable', true);
      const isMarkShape = MARK_SHAPES.has(shape);
      tile.dataset.color = color;
      tile.dataset.shape = shape;
      tile.dataset.text = '';

      if (isMarkShape) {
        tile.className = `mark ${shape} draggable-shape`;
        const symbol = getMarkSymbol(shape);
        tile.innerHTML = `<span>${symbol}</span>`;
        tile.dataset.text = symbol;
        tile.style.backgroundColor = 'transparent';
        tile.style.color = resolveTileColor(color);
      } else if (MULTI_SLOT_SHAPES.has(shape)) {
        tile.className = 'sentence draggable-shape';
        tile.textContent = '';
        tile.dataset.text = '';
        tile.style.backgroundColor = resolveTileColor(tile.dataset.color);
      } else if (shape === 'large-circle') {
        tile.className = 'large-circle draggable-shape';
        tile.textContent = '';
        tile.dataset.text = '';
        tile.style.backgroundColor = resolveTileColor(color);
        tile.style.color = 'white';
      } else {
        tile.className = 'square draggable-shape';
        tile.style.backgroundColor = resolveTileColor(color);
        tile.style.color = 'white';
        tile.textContent = '';
        tile.dataset.text = '';
      }

      registerDraggableShape(tile);
      topContainer.appendChild(tile);
      document.getElementById('colorSelector').style.display = 'none';
    }

    for (let i = 0; i < SLOT_COUNT; i++) {
      const slot = document.createElement('div');
      slot.classList.add('slot');
      slot.dataset.index = i;

      slot.addEventListener('dragover', (e) => {
        e.preventDefault();
        const isCircleDrag =
          e.dataTransfer.getData('circle') ||
          (currentDragShape && currentDragShape.shape === 'circle');
        if (isCircleDrag) {
          clearSlotHighlights();
          return;
        }
        const slotIndex = parseInt(slot.dataset.index, 10);
        const shapeType =
          (currentDragShape && currentDragShape.shape) ||
          e.dataTransfer.getData('shape') ||
          '';
        const span = MULTI_SLOT_SHAPES.has(shapeType) ? SENTENCE_SLOT_SPAN : 1;
        highlightSlotsFrom(slotIndex, span);
      });

      slot.addEventListener('mouseenter', () => {
        if (!selectedElement) return;
        const slotIndex = parseInt(slot.dataset.index, 10);
        const shapeType = selectedElement.type || '';
        const span = MULTI_SLOT_SHAPES.has(shapeType) ? SENTENCE_SLOT_SPAN : 1;
        highlightSlotsFrom(slotIndex, span);
      });

      slot.addEventListener('mouseleave', () => {
        if (!selectedElement) return;
        clearSlotHighlights();
      });



slot.addEventListener('drop', (e) => {

  e.preventDefault();

  // If dragging a circle, don't process as a square drop
  const isCircleDrag =
    e.dataTransfer.getData('circle') ||
    (currentDragShape && currentDragShape.shape === 'circle');
  if (isCircleDrag) {
    clearSlotHighlights();
    currentDragShape = null;
    return;
  }

  const color = e.dataTransfer.getData('color') || e.dataTransfer.getData('move-color');
  const text = e.dataTransfer.getData('text') || '';
  const shapeType =
    (currentDragShape && currentDragShape.shape) ||
    e.dataTransfer.getData('shape') ||
    'square';
  const sourceSlot = e.dataTransfer.getData('source-slot');

  if (sourceSlot !== '') {
    const sourceSlotEl = document.querySelector(`.slot[data-index="${sourceSlot}"]`);
    if (sourceSlotEl && sourceSlotEl !== slot) {
      const movedShape = getTileForSlot(sourceSlotEl);
      if (movedShape) removeTile(movedShape, false);
    }
  }

  const slotIndex = parseInt(slot.dataset.index, 10);
  if (placeTileAtIndex(slotIndex, shapeType, color, text)) {
    dropSound.play();
  }

  clearSlotHighlights();
  currentDragShape = null;
});



slot.addEventListener('click', () => {
  if (!selectedElement) return;
  const selection = { ...selectedElement };
  const slotIndex = parseInt(slot.dataset.index, 10);

  if (
    selection.type === 'square' ||
    selection.type === 'large-circle' ||
    selection.type === 'sentence' ||
    MARK_SHAPES.has(selection.type)
  ) {
    if (placeTileAtIndex(slotIndex, selection.type, selection.color, selection.text)) {
      dropSound.play();
      clearSelection();
    }
    return;
  }
  if (selection.type === 'circle') {
  const droppedShape = getTileForSlot(slot);
  if (droppedShape && droppedShape.querySelectorAll('.circle').length < maxCirclesForTile(droppedShape)) {
    const original = document.querySelector(`.circle[data-id='${selection.id}']`);
    if (!original) return;

    const clone = original.cloneNode(true);
    const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
    clone.dataset.id = uniqueId;
    delete clone.dataset.original;

    clone.setAttribute('draggable', true);
    clone.style.position = 'absolute';

    clone.addEventListener('click', () => removeCircleElement(clone));

    attachCircleToSlot(droppedShape, clone, parseInt(slot.dataset.index, 10));
    updateCirclePositions(droppedShape);
    clearSelection();
    return;
  }

  // Allow dropping into the closest valid empty slot to the right of existing tiles
  const slotList = slots;
  let lastSquareIndex = -1;

  slotList.forEach((s, idx) => {
    if (getTileForSlot(s)) {
      lastSquareIndex = idx;
    }
  });

  const clickedIndex = parseInt(slot.dataset.index);
  if (clickedIndex > lastSquareIndex) {
    const inBetween = slotList.slice(lastSquareIndex + 1, clickedIndex);
    const hasGap = inBetween.some(s => !getTileForSlot(s));
    if (!hasGap) {
      const original = document.querySelector(`.circle[data-id='${selection.id}']`);
      if (!original) return;

      const clone = original.cloneNode(true);
      const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
      clone.dataset.id = uniqueId;
      delete clone.dataset.original;

      clone.setAttribute('draggable', true);
      clone.style.position = 'absolute';

      clone.addEventListener('click', () => removeCircleElement(clone));

      const existingCircle = slot.querySelector('.circle');
      if (existingCircle) slot.removeChild(existingCircle);
      slot.appendChild(clone);
      layoutSlotCircles(slot);

      clearSelection();
    }
  }
}

});
// !!!!!!!!!!!!!!!!!!!!!


      slot.addEventListener('touchmove', (e) => e.preventDefault());
      dropZone.appendChild(slot);
      slots.push(slot);
    }


document.body.addEventListener('drop', (e) => {
  clearSlotHighlights();
  currentDragShape = null;
  const isCircle = e.dataTransfer.getData('circle');
  const circleId = e.dataTransfer.getData('circle-id');

if (isCircle && circleId) {
  const draggedElement = document.querySelector(`.circle[data-id='${circleId}']`);

  // üõ° Do NOT remove original circles
  if (
    draggedElement &&
    !e.target.closest('.dropped-shape') &&
    draggedElement.dataset.original !== 'true'
  ) {
    draggedElement.remove();
  }

  return;
}



  const sourceSlot = e.dataTransfer.getData('source-slot');
  if (sourceSlot !== '') {
    const sourceSlotEl = document.querySelector(`.slot[data-index="${sourceSlot}"]`);
    if (sourceSlotEl && !e.target.closest('.drop-zone')) {
      const draggedShape = getTileForSlot(sourceSlotEl);
      if (draggedShape) removeTile(draggedShape);
    }
  }
});


    




// Keep slot highlights tidy when dragging ends outside the drop zone
document.addEventListener('dragend', () => {
  clearSlotHighlights();
  currentDragShape = null;
});



    function toggleMenu() {
      const menu = document.getElementById('menuContent');
      menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }

    function enableEditMode() {
      editMode = true;
      document.querySelectorAll('#topContainer .draggable-shape').forEach(shape => makeEditableTop(shape));
    }

    function disableEditMode() {
      if (!editMode) return;
      editMode = false;
      document.querySelectorAll('#topContainer .draggable-shape input').forEach(input => {
        const parent = input.parentElement;
        const text = input.value;
        parent.innerHTML = text;
        parent.dataset.text = text;
        parent.classList.add(input.dataset.color);
        if ((parent.dataset.shape || 'square') === 'sentence') {
          parent.style.backgroundColor = resolveTileColor(parent.dataset.color || 'sentence');
        }
      });
    }



    function makeEditableTop(tile) {
      const currentText = tile.dataset.text || tile.textContent;
      const colorClass = tile.dataset.color;
      tile.innerHTML = `<input type="text" value="${currentText}" data-color="${colorClass}">`;
      const input = tile.querySelector('input');
      input.focus();

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-btn';
      deleteBtn.textContent = 'x';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteSound.play();
        topContainer.removeChild(tile);
      });
      tile.appendChild(deleteBtn);

      input.addEventListener('input', () => {
    //    if (!square.dataset.hasSpawned) {
    //      square.dataset.hasSpawned = true;
    //      const newSquare = document.createElement('div');
    //      newSquare.className = 'square ' + colorClass;
    //      newSquare.setAttribute('draggable', true);
    //      newSquare.dataset.color = colorClass;
    //      newSquare.dataset.text = '';
    //      newSquare.addEventListener('dragstart', (e) => {
    //        const text = newSquare.textContent || newSquare.dataset.text || '';
    //        e.dataTransfer.setData('color', colorClass);
    //        e.dataTransfer.setData('text', text);
    //        e.dataTransfer.setData('source-slot', '');
    //      });
    //      topContainer.appendChild(newSquare);
    //    }
      });
    }

    function createDropShape(shapeType, color, text = '') {
      const normalizedShape = shapeType || 'square';
      const tile = document.createElement('div');
      tile.classList.add('dropped-shape');
      const colorKey = color || (normalizedShape === 'sentence' ? 'sentence' : 'red');
      tile.dataset.color = colorKey;
      tile.dataset.shape = normalizedShape;
      tile.dataset.text = text;
      tile.setAttribute('draggable', true);
      tile.textContent = text;
      tile.dataset.tileId = generateTileId();
      tile.dataset.span = MULTI_SLOT_SHAPES.has(normalizedShape) ? SENTENCE_SLOT_SPAN : 1;

      if (MARK_SHAPES.has(normalizedShape)) {
        const symbol = getMarkSymbol(normalizedShape);
        tile.classList.add('dropped-mark', 'mark', normalizedShape);
        tile.dataset.text = symbol;
        tile.innerHTML = `<span>${symbol}</span>`;
        tile.style.backgroundColor = 'transparent';
        tile.style.color = resolveTileColor(colorKey);
      } else if (MULTI_SLOT_SHAPES.has(normalizedShape)) {
        tile.classList.add('dropped-sentence');
        tile.style.backgroundColor = resolveTileColor(colorKey);
        tile.style.color = '#4d3b02';
        tile.textContent = '';
      } else {
        if (normalizedShape === 'large-circle') {
          tile.classList.add('dropped-large-circle');
        } else {
          tile.classList.add('dropped-square');
        }
        tile.style.backgroundColor = resolveTileColor(colorKey);
        tile.style.color = 'white';
      }

      tile.addEventListener('dblclick', () => removeTile(tile));

      tile.addEventListener('dragstart', (ev) => {
        currentDragShape = { shape: normalizedShape };
        applyDragPreview(tile, ev);
        const draggedText = tile.textContent;
        ev.dataTransfer.setData('move-color', tile.dataset.color);
        ev.dataTransfer.setData('text', draggedText);
        ev.dataTransfer.setData('source-slot', tile.parentElement.dataset.index);
        ev.dataTransfer.setData('shape', normalizedShape);
      });

      return tile;
    }

    function placeTileAtIndex(slotIndex, shapeType, color, text) {
      const span = MULTI_SLOT_SHAPES.has(shapeType) ? SENTENCE_SLOT_SPAN : 1;
      if (slotIndex + span > slots.length) return false;

      const occupiedIds = new Set();
      for (let i = 0; i < span; i++) {
        const slot = slots[slotIndex + i];
        if (!slot) return false;
        if (slot.dataset.occupantId) {
          occupiedIds.add(slot.dataset.occupantId);
        }
      }

      occupiedIds.forEach(removeTileById);

      const baseSlot = slots[slotIndex];
      const existingTile = getTileForSlot(baseSlot);
      if (existingTile) removeTile(existingTile, false);

      const newShape = createDropShape(shapeType, color, text);
      baseSlot.appendChild(newShape);
      occupySlots(slotIndex, span, newShape.dataset.tileId);
      if (shapeType === 'square' || MARK_SHAPES.has(shapeType)) {
        layoutSlotCircles(baseSlot);
      }
      if (MULTI_SLOT_SHAPES.has(shapeType)) {
        for (let i = 0; i < span; i++) {
          layoutSlotCircles(slots[slotIndex + i]);
        }
      }
      return true;
    }

    function getTileForSlot(slot) {
      if (!slot) return null;
      const direct = slot.querySelector('.dropped-shape');
      if (direct) return direct;
      const occupantId = slot.dataset.occupantId;
      if (!occupantId) return null;
      return dropZone.querySelector(`.dropped-shape[data-tile-id='${occupantId}']`);
    }

    function occupySlots(startIndex, span, tileId) {
      for (let i = 0; i < span; i++) {
        const slot = slots[startIndex + i];
        if (slot) slot.dataset.occupantId = tileId;
      }
    }

    function clearSlotOccupancy(startIndex, span, tileId) {
      for (let i = 0; i < span; i++) {
        const slot = slots[startIndex + i];
        if (slot && slot.dataset.occupantId === tileId) {
          delete slot.dataset.occupantId;
          Array.from(slot.querySelectorAll('.circle')).forEach(circle => circle.remove());
          layoutSlotCircles(slot);
        }
      }
    }

    function removeTileById(tileId) {
      if (!tileId) return;
      const tile = dropZone.querySelector(`.dropped-shape[data-tile-id='${tileId}']`);
      if (tile) removeTile(tile, false);
    }

    function removeTile(tile, playSound = true) {
      const startIndex = parseInt(tile.parentElement.dataset.index, 10);
      const span = parseInt(tile.dataset.span || '1', 10);
      const tileId = tile.dataset.tileId;
      clearSlotOccupancy(startIndex, span, tileId);
      tile.parentElement.removeChild(tile);
      if (playSound) deleteSound.play();
    }

    function generateTileId() {
      return 'tile-' + Math.random().toString(36).substr(2, 9);
    }

    function attachCircleToSlot(tileEl, circleEl, slotIndex) {
      const baseIndex = parseInt(tileEl.parentElement.dataset.index, 10);
      if (Number.isNaN(baseIndex)) {
        circleEl.dataset.attachedSlot = '';
        return baseIndex;
      }

      const isSentence = tileEl.classList.contains('dropped-sentence');
      const span = isSentence ? SENTENCE_SLOT_SPAN : 1;
      const minIndex = baseIndex;
      const maxIndex = baseIndex + span - 1;
      let assigned = typeof slotIndex === 'number' && !Number.isNaN(slotIndex)
        ? slotIndex
        : baseIndex;
      assigned = Math.max(minIndex, Math.min(maxIndex, assigned));

      const counts = new Map();
      for (let i = 0; i < span; i++) {
        const slot = slots[minIndex + i];
        if (!slot) continue;
        Array.from(slot.querySelectorAll('.circle'))
          .filter(c => c !== circleEl)
          .forEach(c => {
            const idx = Math.max(minIndex, Math.min(maxIndex, parseInt(c.dataset.attachedSlot || (minIndex + i), 10)));
            if (!Number.isNaN(idx)) {
              counts.set(idx, (counts.get(idx) || 0) + 1);
            }
          });
      }

      const capacityPerSlot = 2;
      if ((counts.get(assigned) || 0) >= capacityPerSlot) {
        for (let offset = 1; offset <= span; offset++) {
          const forward = assigned + offset;
          if (forward <= maxIndex && (counts.get(forward) || 0) < capacityPerSlot) {
            assigned = forward;
            break;
          }
          const backward = assigned - offset;
          if (backward >= minIndex && (counts.get(backward) || 0) < capacityPerSlot) {
            assigned = backward;
            break;
          }
        }
      }

      const slotEl = slots[assigned];
      if (slotEl) {
        circleEl.dataset.attachedSlot = assigned;
        circleEl.dataset.parentTile = tileEl.dataset.tileId || '';
        if (circleEl.parentElement !== slotEl) {
          slotEl.appendChild(circleEl);
        }
        layoutSlotCircles(slotEl);
      }
      return assigned;
    }

    function computeSentenceSlotIndex(tileEl, clientX) {
      const baseIndex = parseInt(tileEl.parentElement.dataset.index, 10);
      if (!tileEl.classList.contains('dropped-sentence')) {
        return baseIndex;
      }

      let closestIndex = baseIndex;
      let minDist = Infinity;
      for (let i = 0; i < SENTENCE_SLOT_SPAN; i++) {
        const slot = slots[baseIndex + i];
        if (!slot) continue;
        const rect = slot.getBoundingClientRect();
        const center = rect.left + rect.width / 2;
        const dist = Math.abs(center - clientX);
        if (dist < minDist) {
          minDist = dist;
          closestIndex = baseIndex + i;
        }
      }
      return closestIndex;
    }

    function slotFromPoint(x, y) {
      for (const slot of slots) {
        const rect = slot.getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return slot;
        }
      }
      return null;
    }

    function maxCirclesForTile(tileEl) {
      return tileEl.classList.contains('dropped-sentence')
        ? SENTENCE_SLOT_SPAN * 2
        : 2;
    }

    function removeCircleElement(circleEl) {
      if (!circleEl || circleEl.dataset.original === 'true') return;
      const slotEl = circleEl.parentElement;
      circleEl.remove();
      if (slotEl) {
        layoutSlotCircles(slotEl);
        const tile = getTileForSlot(slotEl);
        if (tile) updateCirclePositions(tile);
      }
      deleteSound.play();
      clearSelection();
    }

    function applyDragPreview(element, event) {
      if (!event.dataTransfer) return;
      const rect = element.getBoundingClientRect();
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(rect.width));
      canvas.height = Math.max(1, Math.round(rect.height));
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const styles = window.getComputedStyle(element);
      ctx.fillStyle = styles.backgroundColor;

      if (element.classList.contains('sentence') || element.classList.contains('dropped-sentence')) {
        const rootStyles = getComputedStyle(document.documentElement);
        const armWidthPx = parseFloat(rootStyles.getPropertyValue('--sentence-arm-width')) || rect.width * 0.2;
        const sentenceWidthPx = parseFloat(rootStyles.getPropertyValue('--sentence-width')) || rect.width;
        const armHeightPx = parseFloat(rootStyles.getPropertyValue('--square-size')) || rect.height / 2;
        const sentenceHeightPx = parseFloat(rootStyles.getPropertyValue('--sentence-height')) || rect.height;
        const armWidth = rect.width * (armWidthPx / sentenceWidthPx);
        const armHeight = rect.height * (armHeightPx / sentenceHeightPx);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(armWidth, 0);
        ctx.lineTo(armWidth, armHeight);
        ctx.lineTo(rect.width, armHeight);
        ctx.lineTo(rect.width, rect.height);
        ctx.lineTo(0, rect.height);
        ctx.closePath();
        ctx.fill();
      } else if (element.classList.contains('large-circle') || element.classList.contains('dropped-large-circle')) {
        ctx.beginPath();
        ctx.arc(rect.width / 2, rect.height / 2, Math.min(rect.width, rect.height) / 2, 0, Math.PI * 2);
        ctx.fill();
      } else if (element.classList.contains('mark') || element.classList.contains('dropped-mark')) {
        const glyphEl = element.querySelector('span') || element;
        const glyphStyles = window.getComputedStyle(glyphEl);
        const symbol =
          (element.dataset.text && element.dataset.text.trim()) ||
          (glyphEl.textContent && glyphEl.textContent.trim()) ||
          getMarkSymbol(element.dataset.shape || '') ||
          '!';
        const fontFamily = glyphStyles.fontFamily || styles.fontFamily || 'sans-serif';
        const fontWeight = glyphStyles.fontWeight || styles.fontWeight || '600';
        const fontSize = glyphStyles.fontSize || `${rect.height * 0.8}px`;
        ctx.fillStyle = glyphStyles.color || '#111';
        ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(symbol, rect.width / 2, rect.height);
      } else {
        ctx.fillRect(0, 0, rect.width, rect.height);
      }

      const text = (element.textContent || '').trim();
      if (text) {
        ctx.fillStyle = styles.color;
        ctx.font = `${styles.fontWeight} ${styles.fontSize} ${styles.fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, rect.width / 2, rect.height / 2, rect.width - 10);
      }

      const offsetX = event.clientX - rect.left;
      const offsetY = event.clientY - rect.top;
      event.dataTransfer.setDragImage(canvas, offsetX, offsetY);
      // Safari/WebKit needs the canvas kept in DOM until drag ends
      canvas.style.position = 'fixed';
      canvas.style.top = '-9999px';
      canvas.style.left = '-9999px';
      document.body.appendChild(canvas);
      setTimeout(() => {
        if (canvas.parentElement) canvas.parentElement.removeChild(canvas);
      }, 0);
    }

    // Handle drop outside of drop-zone to delete square
    document.body.addEventListener('dragover', (e) => e.preventDefault());




document.querySelectorAll('.circle').forEach(circle => {
  circle.addEventListener('click', () => {
    if (!circle.dataset.original) {
      removeCircleElement(circle);
      return;
    }

    selectedElement = {
      type: 'circle',
      id: circle.dataset.id,
    };

    // Visual feedback
    document.querySelectorAll('.circle').forEach(c => c.classList.remove('selected'));
    circle.classList.add('selected');
  });

  circle.addEventListener('dragstart', (e) => {
    const id = circle.dataset.id || Math.random().toString(36).substr(2, 9);
    circle.dataset.id = id;
    currentDragShape = { shape: 'circle' };
    e.dataTransfer.setData('circle', 'true');
    e.dataTransfer.setData('circle-id', id);
  });
});





function updateCirclePositions(tileEl) {
  if (tileEl.classList.contains('dropped-sentence')) {
    const baseIndex = parseInt(tileEl.parentElement.dataset.index, 10);
    for (let i = 0; i < SENTENCE_SLOT_SPAN; i++) {
      layoutSlotCircles(slots[baseIndex + i]);
    }
    return;
  }
  layoutSlotCircles(tileEl.parentElement);
}



function clearSelection() {
  selectedElement = null;
  document.querySelectorAll('.draggable-shape.selected, .circle.selected')
    .forEach(el => el.classList.remove('selected'));
  clearSlotHighlights();
}




// –î–æ–±–∞–≤–∏–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä—è–º–æ –Ω–∞ dropZone –¥–ª—è –¥–µ–ª–µ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
dropZone.addEventListener('drop', (e) => {
  const isCircle = e.dataTransfer.getData('circle');
  if (!isCircle) return;

  const pointerSlot = slotFromPoint(e.clientX, e.clientY);
  let targetShape = pointerSlot ? getTileForSlot(pointerSlot) : null;
  if (!targetShape) {
    const elem = document.elementFromPoint(e.clientX, e.clientY);
    targetShape = elem ? elem.closest('.dropped-shape') : null;
  }
  if (targetShape) {
    e.stopImmediatePropagation(); // üõë 
    if (targetShape.querySelectorAll('.circle').length >= maxCirclesForTile(targetShape)) {
      return;
    }

    const circleId = e.dataTransfer.getData('circle-id');
    const original = document.querySelector(`.circle[data-id='${circleId}']`);
    if (!original) return;

    const clone = original.cloneNode(true);
    const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
    clone.dataset.id = uniqueId;
    delete clone.dataset.original;

    clone.setAttribute('draggable', true);
    clone.style.position = 'absolute';

    clone.addEventListener('dragstart', (e) => {
      currentDragShape = { shape: 'circle' };
      e.dataTransfer.setData('circle', 'true');
      e.dataTransfer.setData('circle-id', clone.dataset.id);
    });

    clone.addEventListener('click', () => removeCircleElement(clone));

    targetShape.appendChild(clone);
    const slotIndex = pointerSlot
      ? parseInt(pointerSlot.dataset.index, 10)
      : targetShape.classList.contains('dropped-sentence')
        ? computeSentenceSlotIndex(targetShape, e.clientX)
        : parseInt(targetShape.parentElement.dataset.index, 10);
    attachCircleToSlot(targetShape, clone, slotIndex);
    updateCirclePositions(targetShape);
    currentDragShape = null;
  }
});




dropZone.addEventListener('drop', (e) => {
  e.preventDefault();

  const isCircle = e.dataTransfer.getData('circle');
  const circleId = e.dataTransfer.getData('circle-id');
  if (!isCircle || !circleId) return;

  const original = document.querySelector(`.circle[data-id='${circleId}']`);
  if (!original) return;

  const pointerSlot = slotFromPoint(e.clientX, e.clientY);
  if (pointerSlot && !getTileForSlot(pointerSlot)) {
    const clone = original.cloneNode(true);
    const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
    clone.dataset.id = uniqueId;
    delete clone.dataset.original;

    clone.setAttribute('draggable', true);
    clone.style.position = 'absolute';

    clone.addEventListener('dragstart', (evt) => {
      currentDragShape = { shape: 'circle' };
      evt.dataTransfer.setData('circle', 'true');
      evt.dataTransfer.setData('circle-id', clone.dataset.id);
    });

    clone.addEventListener('click', () => removeCircleElement(clone));

    const existingCircle = pointerSlot.querySelector('.circle');
    if (existingCircle) pointerSlot.removeChild(existingCircle);
    pointerSlot.appendChild(clone);
    layoutSlotCircles(pointerSlot);
    clearSelection();
    currentDragShape = null;
    return;
  }

  const slotList = slots;

  // –ù–∞–π—Ç–∏ –∏–Ω–¥–µ–∫—Å —Å–∞–º–æ–≥–æ –ø—Ä–∞–≤–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–∞
  let lastSquareIndex = -1;
  slotList.forEach((slot, index) => {
    if (getTileForSlot(slot)) {
      lastSquareIndex = index;
    }
  });

  // –ï—Å–ª–∏ –Ω–µ—Ç –Ω–∏ –æ–¥–Ω–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–∞ ‚Äî –Ω–µ —Ä–∞–∑—Ä–µ—à–∞–µ–º
  if (lastSquareIndex === -1) return;

  // –ù–∞–π—Ç–∏ –ø–µ—Ä–≤—ã–π –¥–æ–ø—É—Å—Ç–∏–º—ã–π —Å–ª–æ—Ç —Å–ø—Ä–∞–≤–∞ –æ—Ç —Å–∞–º–æ–≥–æ –ø—Ä–∞–≤–æ–≥–æ –∫–≤–∞–¥—Ä–∞—Ç–∏–∫–∞
 


  let targetSlot = null;
  for (let i = lastSquareIndex + 1; i < slotList.length; i++) {
    if (!getTileForSlot(slotList[i])) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –º–µ–∂–¥—É lastSquareIndex –∏ i ‚Äî –≤—Å–µ –∑–∞–Ω—è—Ç—ã
      const hasGap = slotList.slice(lastSquareIndex + 1, i).some(s => !getTileForSlot(s));
      if (!hasGap) {
        targetSlot = slotList[i];
        break;
      }
    }
  }










  if (!targetSlot) return;

  // –ö–ª–æ–Ω–∏—Ä—É–µ–º –∫—Ä—É–∂–æ–∫
  const clone = original.cloneNode(true);
  const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
  clone.dataset.id = uniqueId;
  delete clone.dataset.original;

  clone.setAttribute('draggable', true);
  clone.style.position = 'absolute';

//  clone.addEventListener('dragstart', (e) => {
//    e.dataTransfer.setData('circle', 'true');
//    e.dataTransfer.setData('circle-id', clone.dataset.id);
//  });

  
clone.addEventListener('dragstart', (e) => {
  currentDragShape = { shape: 'circle' };
  e.dataTransfer.setData('circle', 'true');
  e.dataTransfer.setData('circle-id', clone.dataset.id);
});

clone.addEventListener('click', () => {
  removeCircleElement(clone);
});


  const existingCircle = targetSlot.querySelector('.circle');
  if (existingCircle) targetSlot.removeChild(existingCircle);
    targetSlot.appendChild(clone);
    layoutSlotCircles(targetSlot);
    clearSelection();
    currentDragShape = null;
});

//if (isMobile) {
  dropZone.addEventListener('click', (e) => {
    const circle = e.target.closest('.circle');
    if (circle && !circle.dataset.original) {
      removeCircleElement(circle);
      return;
    }

    const tile = e.target.closest('.dropped-shape');
    if (tile && dropZone.contains(tile)) {
      const baseSlot = tile.parentElement;
      const baseIndex = baseSlot ? parseInt(baseSlot.dataset.index, 10) : NaN;
      const span = parseInt(tile.dataset.span || '1', 10);
      let hasCircles = false;

      if (!Number.isNaN(baseIndex)) {
        for (let i = 0; i < span; i++) {
          const slotEl = slots[baseIndex + i];
          if (slotEl && slotEl.querySelector('.circle')) {
            hasCircles = true;
            break;
          }
        }
      }

      if (!hasCircles) {
        removeTile(tile);
        clearSelection(); // Ensure no lingering selections
      }
    }

  });
//}






  </script>
</body>
</html>
