<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drag and Drop Learning Tool</title>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: sans-serif;
      background-color: #fff;
    }

    .menu {
      position: absolute;
      top: 20px;
      right: 20px;
    }

    .menu-button {
      width: 120px;
      height: 90px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      cursor: pointer;
    }

    .menu-button span {
      height: 4px;
      background-color: #fff;
      border-radius: 2px;
    }

    .menu-content {
      display: none;
      position: absolute;
      right: 0;
      top: 35px;
      background-color: white;
      border: 1px solid #ccc;
      box-shadow: 0px 2px 8px rgba(0,0,0,0.15);
      padding: 10px;
      z-index: 100;
    }

    .menu-content a {
      display: block;
      text-decoration: none;
      color: #333;
      padding: 5px 0;
      cursor: pointer;
    }

    .menu-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      color: #333;
      padding: 6px 0;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }

    .edit-toolbar {
      display: none;
      margin-top: 8px;
      padding: 6px 10px;
      background-color: #fffbe6;
      border: 1px solid #f0d98a;
      border-radius: 6px;
      gap: 10px;
      align-items: center;
      justify-content: flex-start;
      flex-wrap: wrap;
      max-width: 220px;
    }

    .edit-toolbar.active {
      display: flex;
    }

    .edit-toolbar span {
      font-weight: 600;
      color: #7a640d;
    }

    .text-color-btn {
      border: 1px solid #c5c5c5;
      background: #fff;
      color: #333;
      padding: 4px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }

    .text-color-btn.active {
      border-color: #2ecc71;
      background-color: #eaf8f0;
    }

    :root {
      --square-size: 40px;
      --tower-height: calc(var(--square-size) * 2);
      --tower-text-offset: calc(var(--tower-height) - var(--square-size));
      --sentence-width: 140px;
      --sentence-height: 65px;
      --sentence-text-offset: calc(var(--sentence-height) - var(--square-size) + 3px);
      --sentence-arm-width: 40px;
      --sentence-arm-height: 40px;
      --sentence-default-color: #2ecc71;
      --sentence-radius: 6px;
      --slot-gap: 10px;
      --tile-text-color-dark: #2b2100;
      --tile-text-color-light: #fdfbf2;
      --tile-text-color: var(--tile-text-color-light);
    }

    .container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 50px;
      margin-bottom: 50px;
      flex-wrap: wrap;
    }

    #topContainer {
      align-items: flex-end;
      min-height: calc(var(--tower-height) + 20px);
    }

    .square {
      width: var(--square-size);
      height: var(--square-size);
      cursor: grab;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: var(--tile-text-color);
      font-weight: bold;
      position: relative;
      touch-action: none;
      border-radius: 6px;
      }

    .tower,
    .dropped-tower {
      width: var(--square-size);
      height: var(--tower-height);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: var(--tile-text-color);
      font-weight: bold;
      position: relative;
      border-radius: 6px;
      box-sizing: border-box;
      text-align: center;
      padding-top: var(--tower-text-offset);
      padding-bottom: 0;
      line-height: var(--square-size);
    }

    .tower {
      cursor: grab;
      touch-action: none;
    }

    .dropped-tower {
      cursor: move;
      position: absolute;
      bottom: 0;
      left: 0;
      z-index: 3;
    }

    .tower input,
    .dropped-tower input {
      height: var(--square-size);
      line-height: var(--square-size);
      align-self: center;
      padding: 0 6px;
      box-sizing: border-box;
    }

    .image-tile,
    .dropped-image {
      height: var(--tower-height);
      min-width: var(--square-size);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 700;
      color: var(--tile-text-color);
      border-radius: 6px;
      box-sizing: border-box;
      padding-top: var(--tower-text-offset);
      padding-bottom: 0;
      line-height: var(--square-size);
      position: relative;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      overflow: hidden;
      touch-action: none;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.45);
    }

    .image-tile {
      cursor: grab;
    }

    .dropped-image {
      cursor: move;
      position: absolute;
      bottom: 0;
      left: 0;
      z-index: 3;
    }

    .image-tile input,
    .dropped-image input {
      height: var(--square-size);
      line-height: var(--square-size);
      align-self: center;
      padding: 0 6px;
      box-sizing: border-box;
      background: rgba(0,0,0,0.25);
    }

    .large-circle {
      width: var(--square-size);
      height: var(--square-size);
      cursor: grab;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: var(--tile-text-color);
      font-weight: bold;
      position: relative;
      touch-action: none;
      border-radius: 50%;
    }

    .strip,
    .dropped-strip {
      height: var(--square-size);
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      font-size: 20px;
      font-weight: 600;
      padding: 6px 10px;
      box-sizing: border-box;
      color: var(--tile-text-color);
    }

    .strip {
      cursor: grab;
      position: relative;
      touch-action: none;
    }

    .dropped-strip {
      position: absolute;
      bottom: 0;
      left: 0;
      cursor: move;
      z-index: 3;
    }

    /* L-shaped sentence token inspired by form.png */
    .sentence,
    .dropped-sentence {
      width: var(--sentence-width);
      height: var(--sentence-height);
      background-color: var(--sentence-default-color);
      clip-path: polygon(
        0 0,
        calc(var(--sentence-arm-width) / var(--sentence-width) * 100%) 0,
        calc(var(--sentence-arm-width) / var(--sentence-width) * 100%)
          calc((var(--sentence-height) - var(--square-size)) / var(--sentence-height) * 100%),
        100% calc((var(--sentence-height) - var(--square-size))/ var(--sentence-height) * 100%),
        100% 100%,
        0 100%
      );
      border-radius: var(--sentence-radius);
      color: var(--tile-text-color);
      font-weight: 600;
      font-size: 20px;
      padding: 8px;
      padding-top: var(--sentence-text-offset);
      padding-bottom: 0;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      text-align: left;
      line-height: var(--square-size);
    }

    .sentence {
      cursor: grab;
      position: relative;
      touch-action: none;
    }

    .dropped-sentence {
      position: absolute;
      bottom: 0;
      left: 0;
      cursor: move;
      z-index: 3;
    }

    .mark,
    .dropped-mark {
      width: var(--square-size);
      height: var(--sentence-height);
      position: relative;
      cursor: grab;
      touch-action: none;
      display: flex;
      align-items: flex-start;
      justify-content: center;

    
    }

    .dropped-mark {
      cursor: move;
      position: absolute;
      bottom: 0;
      left: 0;
      z-index: 3;
    }

    .mark span,
    .dropped-mark span {
      position: absolute;
      bottom: -0.08em;
      width: 100%;
      text-align: center;
      font-size: calc(var(--sentence-height) * 0.9);
      font-weight: 600;
      font-family: 'Trebuchet MS', 'Segoe UI', sans-serif;
      line-height: 1;
      color: inherit;
    }


    .draggable-shape input {
      width: 100%;
      height: 100%;
      border: none;
      background: transparent;
      color: var(--tile-text-color);
      font-weight: inherit;
      font-size: inherit;
      text-align: inherit;
    }

    .delete-btn {
      position: absolute;
      top: 2px;
      right: 4px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: white;
      border: none;
      border-radius: 50%;
      width: 16px;
      height: 16px;
      text-align: center;
      line-height: 14px;
      cursor: pointer;
      display: none;
      z-index: 10;
    }

    .draggable-shape:hover .delete-btn {
      display: block;
    }

    .sentence .delete-btn,
    .dropped-sentence .delete-btn {
      top: calc(var(--sentence-height) - var(--square-size) + 2px);
    }

    .red { background-color: #d7263d; }
    .blue { background-color: #276bd7; }
    .purple { background-color: #6c2ed7; }
    .green { background-color: #2ecc71; }
    .brown { background-color: #8b5e3c; }
    .turquoise { background-color: #1abc9c; }

    #dropZoneStack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 40px;
    }

    .drop-zone {
      width: 1850px;
      height: 120px;
      margin: 0 auto;
      display: flex;
      justify-content: flex-start;
      align-items: flex-end;
      align-content: flex-start;
      background-color: #f9f9f9;
      padding: 10px;
      box-sizing: border-box;
      flex-wrap: wrap;
      gap: var(--slot-gap);
    }

    .slot {
      width: var(--square-size);
      height: var(--square-size);
      position: relative;
      flex-shrink: 0;
      touch-action: none;
      transform: translateY(45px);
    }

    .slot.highlighted {
      outline: 2px dashed lightgrey;
      outline-offset: 0;
    }



    .dropped-shape {
      position: absolute;
      bottom: 0;
      left: 0;
      cursor: move;
      display: flex;
      font-weight: bold;
      box-sizing: border-box;
      transform-origin: bottom left;
      z-index: 2;
    }

    .dropped-square {
      width: var(--square-size);
      height: var(--square-size);
      border-radius: 6px;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: var(--tile-text-color);
      text-align: center;
    }

    .dropped-large-circle {
      width: var(--square-size);
      height: var(--square-size);
      border-radius: 50%;
      justify-content: center;
      align-items: center;
      font-size: 22px;
      color: var(--tile-text-color);
      text-align: center;
    }

    #colorSelector {
      display:none;
      position:absolute;
      top:70px;
      right:20px;
      background:#fff;
      border:1px solid #ccc;
      padding:10px;
      z-index:100;
    }

    .length-control {
      display: none;
      margin-top: 6px;
    }





.circle {
  width: 15px;
  height: 15px;
  background-color: #FFD700;
  border-radius: 50%;
  position: absolute;
  cursor: grab;
  z-index: 50;
  pointer-events: auto;
}


.selected {
  outline: 3px solid orange;
  outline-offset: -3px;
  animation: pulse 1s infinite alternate;
}

.selected {
  outline: 3px solid #FFD700;
  box-shadow: 0 0 10px #FFD700;
}


@keyframes pulse {
  from { outline-color: orange; }
  to { outline-color: gold; }
}




  </style>
</head>
<body>
  <!-- Menu -->
  <div class="menu">
    <div class="menu-button" onclick="toggleMenu()">
      <span></span>
      <span></span>
      <span></span>
    </div>
    <div class="menu-content" id="menuContent">
      <a href="#" id="editButton">Edit</a>
      <a href="#" id="addSquareButton">Add</a>
      <a href="#" id="addPictureButton">Add Picture</a>
      <a href="#" id="clearLinkButton">Clear</a>
      <a href="#" id="shareLinkButton">Share</a>
      <div class="edit-toolbar" id="editToolbar">
        <span>Text color:</span>
        <button type="button" class="text-color-btn" data-text-color="dark">Deep brown</button>
        <button type="button" class="text-color-btn" data-text-color="light">Light chalk</button>
      </div>
      <label class="menu-toggle">
        <input type="checkbox" id="singleUseToggle">
        Single-use palette
      </label>
    </div>
  </div>

  <!-- Color selector -->
  <div id="colorSelector">
    <label for="shapeChoice">Tile Type:</label>
    <select id="shapeChoice">
      <option value="square">Square</option>
      <option value="tower">Tower</option>
      <option value="sentence">Sentence</option>
      <option value="strip">Rectangle Strip</option>
      <option value="large-circle">Large Circle</option>
      <option value="exclamation">Exclamation</option>
      <option value="question">Question</option>
      <option value="period">Period</option>
      <option value="comma">Comma</option>
      <option value="colon">Colon</option>
      <option value="semicolon">Semicolon</option>
      <option value="quote">Quotation Mark</option>
      <option value="apostrophe">Apostrophe</option>
    </select>
    <label for="formLength" id="lengthLabel" class="length-control">Length:</label>
    <select id="formLength" class="length-control">
      <option value="2">2 Squares</option>
      <option value="3">3 Squares</option>
      <option value="4">4 Squares</option>
      <option value="5">5 Squares</option>
    </select>
    <label for="colorChoice">Color:</label>
    <select id="colorChoice">
      <option value="red">Red</option>
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="green">Green</option>
      <option value="brown">Brown</option>
      <option value="turquoise">Turquoise</option>
      <option value="orange">Orange</option>
      <option value="yellow">Yellow</option>
      <option value="pink">Pink</option>
      <option value="black">Black</option>
      <option value="gray">Gray</option>
      <option value="cyan">Cyan</option>
      <option value="lime">Lime</option>
      <option value="navy">Navy</option>
      <option value="teal">Teal</option>
      <option value="magenta">Magenta</option>
    </select>
    <button onclick="addNewTile()">Add Tile</button>
  </div>
  <input type="file" id="imagePicker" accept="image/*" multiple style="display:none;">

  <!-- Draggable squares -->
  <div class="container" id="topContainer"></div>

  <!-- Drop zones with slots -->
  <div id="dropZoneStack">
    <div class="drop-zone" data-zone="0"></div>
    <div class="drop-zone" data-zone="1"></div>
    <div class="drop-zone" data-zone="2"></div>
    <div class="drop-zone" data-zone="3"></div>
  </div>

<div style="height: 50px;"></div>




<div class="container">
<div class="circle" draggable="true" data-original="true" data-id="circle-1"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-2"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-3"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-4"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-5"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-6"></div>

<div class="circle" draggable="true" data-original="true" data-id="circle-7"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-8"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-9"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-10"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-11"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-12"></div>

<div class="circle" draggable="true" data-original="true" data-id="circle-13"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-14"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-15"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-16"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-17"></div>
<div class="circle" draggable="true" data-original="true" data-id="circle-18"></div>




</div>






  <!-- âœ¨ Audio -->
  <audio id="dropSound" src="drop.mp3"></audio>
  <audio id="deleteSound" src="delete.mp3"></audio>

  <script>

    let selectedElement = null;
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);


    let editMode = false;
    let currentDragShape = null;
    let focusedEditableTile = null;
    let singleUseMode = false;
    const dropZone = document.getElementById('dropZoneStack');
    const dropZones = Array.from(dropZone.querySelectorAll('.drop-zone'));
    const topContainer = document.getElementById('topContainer');
    const dropSound = document.getElementById('dropSound');
    const deleteSound = document.getElementById('deleteSound');
    const editToolbar = document.getElementById('editToolbar');
    const singleUseToggle = document.getElementById('singleUseToggle');
    const shareLinkButton = document.getElementById('shareLinkButton');
    const clearLinkButton = document.getElementById('clearLinkButton');
    const textColorButtons = editToolbar
      ? Array.from(editToolbar.querySelectorAll('[data-text-color]'))
      : [];
    const shapeChoiceEl = document.getElementById('shapeChoice');
    const lengthLabelEl = document.getElementById('lengthLabel');
    const formLengthSelect = document.getElementById('formLength');
    const addPictureButton = document.getElementById('addPictureButton');
    const imagePickerEl = document.getElementById('imagePicker');
    const TILE_COLORS = {
      red: '#d7263d',
      blue: '#276bd7',
      purple: '#6c2ed7',
      green: '#2ecc71',
      brown: '#8b5e3c',
      turquoise: '#1abc9c',
      sentence: '#ffe085',
      orange: '#f39c12',
      yellow: '#f1c40f',
      pink: '#ff69b4',
      black: '#333333',
      gray: '#95a5a6',
      cyan: '#00bcd4',
      lime: '#9acd32',
      navy: '#001f3f',
      teal: '#008080',
      magenta: '#d81b60',
    };
    const MULTI_SLOT_SHAPES = new Set(['sentence', 'strip']);
    const MARK_SHAPES = new Set([
      'exclamation',
      'question',
      'period',
      'comma',
      'colon',
      'semicolon',
      'quote',
      'apostrophe',
    ]);
    const MARK_SYMBOLS = {
      exclamation: '!',
      question: '?',
      period: '.',
      comma: ',',
      colon: ':',
      semicolon: ';',
      quote: '"',
      apostrophe: "'",
    };
    const rootStyles = getComputedStyle(document.documentElement);
    const BASE_TILE_SIZE = parseInt(rootStyles.getPropertyValue('--square-size')) || 80;
    const SLOT_GAP = parseInt(rootStyles.getPropertyValue('--slot-gap')) || 10;
    const SENTENCE_WIDTH = parseFloat(rootStyles.getPropertyValue('--sentence-width')) || BASE_TILE_SIZE;
    const SENTENCE_SLOT_SPAN = Math.max(1, Math.round((SENTENCE_WIDTH + SLOT_GAP) / (BASE_TILE_SIZE + SLOT_GAP)));
    const CIRCLE_SIZE = Math.max(6, Math.round(BASE_TILE_SIZE * 0.375));
    const CIRCLE_GAP = Math.max(2, Math.round(BASE_TILE_SIZE * 0.125));
    const TOWER_HEIGHT = parseFloat(rootStyles.getPropertyValue('--tower-height')) || BASE_TILE_SIZE * 2;
    const TEXT_COLOR_DARK =
      (rootStyles.getPropertyValue('--tile-text-color-dark') || '#2b2100').trim() || '#2b2100';
    const TEXT_COLOR_LIGHT =
      (rootStyles.getPropertyValue('--tile-text-color-light') || '#fdfbf2').trim() || '#fdfbf2';
    const TEXT_COLORS = {
      dark: TEXT_COLOR_DARK,
      light: TEXT_COLOR_LIGHT,
    };
    const SHARE_SHAPE_KEYS = [
      'square',
      'sentence',
      'strip',
      'large-circle',
      'exclamation',
      'question',
      'period',
      'comma',
      'colon',
      'semicolon',
      'quote',
      'apostrophe',
      'tower',
      'image',
    ];
    const SHARE_SHAPE_LOOKUP = SHARE_SHAPE_KEYS.reduce((acc, key, index) => {
      acc[key] = index;
      return acc;
    }, {});
    const SHARE_COLOR_KEYS = Object.keys(TILE_COLORS);
    const SHARE_COLOR_LOOKUP = SHARE_COLOR_KEYS.reduce((acc, key, index) => {
      acc[key] = index;
      return acc;
    }, {});
    const SHARE_TEXT_COLOR_KEYS = ['light', 'dark'];
    const SHARE_TEXT_COLOR_LOOKUP = SHARE_TEXT_COLOR_KEYS.reduce((acc, key, index) => {
      acc[key] = index;
      return acc;
    }, {});
    const SHARE_STATE_VERSION = 3;
    const circleTemplate = document.querySelector('.circle[data-original="true"]');
    const dropZoneWidth = (dropZones[0] && dropZones[0].clientWidth) || 1200;
    const SLOT_COUNT_PER_ZONE = Math.max(
      SENTENCE_SLOT_SPAN,
      Math.floor(dropZoneWidth / (BASE_TILE_SIZE + SLOT_GAP))
    );
    const slots = [];
    let highlightedSlotEls = [];

    function getMarkSymbol(shape) {
      return MARK_SYMBOLS[shape] || '';
    }

    function layoutSlotCircles(slotEl) {
      if (!slotEl) return;
      const circles = Array.from(slotEl.querySelectorAll('.circle'));
      if (!circles.length) return;
      let dynamicGap = CIRCLE_GAP;
      const slotHeight = slotEl.clientHeight || slotEl.offsetHeight;
      const slotWidth = slotEl.clientWidth || slotEl.offsetWidth;
      const maxCircles = Math.min(circles.length, 3);
      circles.slice(maxCircles).forEach(circle => circle.remove());
      const activeCircles = circles.slice(0, maxCircles);
      let circleSize = CIRCLE_SIZE;
      if (maxCircles === 3) {
        dynamicGap = 0;
        circleSize = slotWidth >= 39 ? 13 : slotWidth / 3;
      } else {
        const requiredWidth = circleSize * maxCircles + dynamicGap * (maxCircles - 1);
        if (requiredWidth > slotWidth) {
          const availableWidth = slotWidth - dynamicGap * (maxCircles - 1);
          circleSize = availableWidth / maxCircles;
        }
      }
      const top = (slotHeight - circleSize) / 2;
      if (maxCircles === 1) {
        const left = (slotWidth - circleSize) / 2;
        activeCircles[0].style.width = `${circleSize}px`;
        activeCircles[0].style.height = `${circleSize}px`;
        activeCircles[0].style.top = `${top}px`;
        activeCircles[0].style.left = `${left}px`;
        return;
      }
      const totalWidth = circleSize * maxCircles + dynamicGap * (maxCircles - 1);
      const firstLeft = (slotWidth - totalWidth) / 2;
      activeCircles.forEach((circle, idx) => {
        circle.style.width = `${circleSize}px`;
        circle.style.height = `${circleSize}px`;
        circle.style.top = `${top}px`;
        circle.style.left = `${firstLeft + idx * (circleSize + dynamicGap)}px`;
      });
    }

    function resolveTileColor(key) {
      return TILE_COLORS[key] || key || '#777';
    }

    function resolveTextColor(key) {
      return TEXT_COLORS[key] || TEXT_COLOR_LIGHT;
    }

    function applyTextColorToTile(tile, colorKey = 'light') {
      if (!tile) return;
      const shapeType = tile.dataset.shape || 'square';
      tile.dataset.textColor = colorKey;
      if (MARK_SHAPES.has(shapeType)) return;
      const colorValue = resolveTextColor(colorKey);
      tile.style.color = colorValue;
      const input = tile.querySelector('input');
      if (input) input.style.color = colorValue;
    }

    function clampStripSpan(value) {
      const span = parseInt(value, 10);
      if (Number.isNaN(span)) return 2;
      return Math.min(5, Math.max(2, span));
    }

    function computeStripWidth(span) {
      if (span <= 1) return BASE_TILE_SIZE;
      return span * BASE_TILE_SIZE + (span - 1) * SLOT_GAP;
    }

    function computeImageSpan(aspectRatio) {
      const aspect = parseFloat(aspectRatio) || 1;
      const widthPx = Math.max(BASE_TILE_SIZE, TOWER_HEIGHT * aspect);
      return Math.max(1, Math.round((widthPx + SLOT_GAP) / (BASE_TILE_SIZE + SLOT_GAP)));
    }

    function applyImageDimensions(tile, aspectOverride) {
      if (!tile) return;
      const aspect =
        typeof aspectOverride === 'number'
          ? aspectOverride
          : parseFloat(tile.dataset.aspectRatio) || 1;
      const widthPx = Math.max(BASE_TILE_SIZE, TOWER_HEIGHT * aspect);
      tile.style.width = `${widthPx}px`;
      const span = computeImageSpan(aspect);
      tile.dataset.span = span;
    }

    function applyStripDimensions(tile, spanValue) {
      if (!tile) return;
      const span = Math.max(1, parseInt(spanValue, 10) || 1);
      tile.style.width = `${computeStripWidth(span)}px`;
      tile.style.height = `${BASE_TILE_SIZE}px`;
    }

    function resolveShapeSpan(shapeType, providedSpan) {
      if (shapeType === 'sentence') {
        return SENTENCE_SLOT_SPAN;
      }
      if (shapeType === 'strip') {
        return clampStripSpan(providedSpan || 2);
      }
      const span = parseInt(providedSpan, 10);
      return !Number.isNaN(span) && span > 0 ? span : 1;
    }

    function clearSlotHighlights() {
      if (!highlightedSlotEls.length) return;
      highlightedSlotEls.forEach(slotEl => {
        if (slotEl) slotEl.classList.remove('highlighted');
      });
      highlightedSlotEls = [];
    }

    function highlightSlotsFrom(startIndex, span) {
      clearSlotHighlights();
      if (Number.isNaN(startIndex)) return;
      for (let i = 0; i < span; i++) {
        const slotEl = slots[startIndex + i];
        if (!slotEl) break;
        slotEl.classList.add('highlighted');
        highlightedSlotEls.push(slotEl);
      }
    }

    function updateTextColorMenuSelection(selectedKey) {
      if (!textColorButtons.length) return;
      textColorButtons.forEach(btn => {
        if (selectedKey && btn.dataset.textColor === selectedKey) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    function setFocusedEditableTile(tile) {
      if (tile && !MARK_SHAPES.has(tile.dataset.shape || '')) {
        focusedEditableTile = tile;
        updateTextColorMenuSelection(tile.dataset.textColor || 'light');
      } else {
        focusedEditableTile = null;
        updateTextColorMenuSelection(null);
      }
    }

    textColorButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const colorKey = btn.dataset.textColor || 'light';
        if (!focusedEditableTile || MARK_SHAPES.has(focusedEditableTile.dataset.shape || '')) {
          return;
        }
        applyTextColorToTile(focusedEditableTile, colorKey);
        updateTextColorMenuSelection(colorKey);
      });
    });

    function registerDraggableShape(element) {
      element.classList.add('draggable-shape');
      if (!element.dataset.paletteId) {
        element.dataset.paletteId = 'palette-' + Math.random().toString(36).substr(2, 9);
      }
      const shapeType = element.dataset.shape || 'square';
      element.dataset.shape = shapeType;
      const baseSpan = resolveShapeSpan(shapeType, element.dataset.span || 1);
      element.dataset.span = baseSpan;
      if (!element.dataset.textColor) {
        element.dataset.textColor = 'light';
      }
      applyTextColorToTile(element, element.dataset.textColor);
      if (shapeType === 'strip') {
        applyStripDimensions(element, baseSpan);
      } else if (shapeType === 'image') {
        applyImageDimensions(element);
      }

      element.addEventListener('click', () => {
        selectedElement = {
          type: shapeType,
          color: element.dataset.color,
          text: element.dataset.text || element.textContent || '',
          textColor: element.dataset.textColor || 'light',
          span: parseInt(element.dataset.span || '1', 10) || 1,
          sourceEl: element,
          paletteId: element.dataset.paletteId || '',
          imageSrc: element.dataset.imageSrc || '',
          aspectRatio: element.dataset.aspectRatio || '',
        };

        document.querySelectorAll('#topContainer .draggable-shape').forEach(sq => sq.classList.remove('selected'));
        element.classList.add('selected');
        clearSlotHighlights();
      });

      if (MULTI_SLOT_SHAPES.has(element.dataset.shape || 'square')) {
        element.style.backgroundColor = resolveTileColor(element.dataset.color || 'sentence');
      } else if (MARK_SHAPES.has(element.dataset.shape || '')) {
        element.classList.add('mark', element.dataset.shape);
        const symbol = getMarkSymbol(element.dataset.shape);
        element.dataset.text = symbol;
        let span = element.querySelector('span');
        if (!span) {
          span = document.createElement('span');
          element.textContent = '';
          element.appendChild(span);
        }
        span.textContent = symbol;
        element.style.color = resolveTileColor(element.dataset.color || '#111');
      }

      element.addEventListener('dragstart', (e) => {
        const text = element.dataset.text || element.textContent || '';
        const span = parseInt(element.dataset.span || '1', 10) || 1;
        const textColor = element.dataset.textColor || 'light';
        currentDragShape = {
          shape: shapeType,
          span,
          textColor,
          paletteId: element.dataset.paletteId || '',
          imageSrc: element.dataset.imageSrc || '',
          aspectRatio: element.dataset.aspectRatio || '',
        };
        applyDragPreview(element, e);
        e.dataTransfer.setData('color', element.dataset.color || '');
        e.dataTransfer.setData('text', text);
        e.dataTransfer.setData('shape', shapeType);
        e.dataTransfer.setData('span', span.toString());
        e.dataTransfer.setData('text-color', textColor);
        e.dataTransfer.setData('source-slot', '');
        e.dataTransfer.setData('palette-id', element.dataset.paletteId || '');
        if (element.dataset.imageSrc) {
          e.dataTransfer.setData('image-src', element.dataset.imageSrc);
        }
        if (element.dataset.aspectRatio) {
          e.dataTransfer.setData('image-aspect', element.dataset.aspectRatio);
        }
      });
    }

    function createTopTile(config = {}) {
      const shape = typeof config.shape === 'string' ? config.shape : 'square';
      const color = typeof config.color === 'string' ? config.color : 'red';
      const textColor =
        typeof config.textColor === 'string' && TEXT_COLORS[config.textColor]
          ? config.textColor
          : 'light';
      const textValue = typeof config.text === 'string' ? config.text : '';
      const spanValue = resolveShapeSpan(shape, config.span);
      const tile = document.createElement('div');
      tile.setAttribute('draggable', true);
      tile.dataset.shape = shape;
      tile.dataset.color = color;
      tile.dataset.span = spanValue;
      tile.dataset.textColor = textColor;
      const isMarkShape = MARK_SHAPES.has(shape);

      if (isMarkShape) {
        const symbol = getMarkSymbol(shape);
        tile.className = `mark ${shape} draggable-shape`;
        tile.innerHTML = `<span>${symbol}</span>`;
        tile.dataset.text = symbol;
        tile.style.backgroundColor = 'transparent';
        tile.style.color = resolveTileColor(color);
      } else if (shape === 'sentence') {
        tile.className = 'sentence draggable-shape';
        tile.textContent = textValue;
        tile.dataset.text = textValue;
        tile.style.backgroundColor = resolveTileColor(color || 'sentence');
      } else if (shape === 'strip') {
        tile.className = 'strip draggable-shape';
        tile.textContent = textValue;
        tile.dataset.text = textValue;
        applyStripDimensions(tile, spanValue);
        tile.style.backgroundColor = resolveTileColor(color);
      } else if (shape === 'large-circle') {
        tile.className = 'large-circle draggable-shape';
        tile.textContent = textValue;
        tile.dataset.text = textValue;
        tile.style.backgroundColor = resolveTileColor(color);
      } else if (shape === 'tower') {
        tile.className = 'tower draggable-shape';
        tile.textContent = textValue;
        tile.dataset.text = textValue;
        tile.style.backgroundColor = resolveTileColor(color);
      } else if (shape === 'image' && config.imageSrc) {
        tile.className = 'image-tile draggable-shape';
        tile.dataset.imageSrc = config.imageSrc;
        const aspect = parseFloat(config.aspectRatio) || 1;
        tile.dataset.aspectRatio = aspect;
        tile.textContent = textValue;
        tile.dataset.text = textValue;
        tile.dataset.span = computeImageSpan(aspect);
        applyImageDimensions(tile, aspect);
        tile.style.backgroundImage = `url('${config.imageSrc}')`;
        tile.style.backgroundColor = '#ccc';
      } else {
        tile.className = 'square draggable-shape';
        tile.textContent = textValue;
        tile.dataset.text = textValue;
        tile.style.backgroundColor = resolveTileColor(color);
      }

      registerDraggableShape(tile);
      topContainer.appendChild(tile);
      return tile;
    }

    document.addEventListener('click', (e) => {
      if (
        !e.target.closest('.draggable-shape input') &&
        !e.target.closest('#editButton') &&
        !e.target.closest('#editToolbar')
      ) {
        disableEditMode();
      }
    });

    document.getElementById('editButton').addEventListener('click', (e) => {
      e.preventDefault();
      enableEditMode();
    });

    document.getElementById('addSquareButton').addEventListener('click', (e) => {
      e.preventDefault();
      const selector = document.getElementById('colorSelector');
      selector.style.display = selector.style.display === 'block' ? 'none' : 'block';
    });

    if (addPictureButton && imagePickerEl) {
      addPictureButton.addEventListener('click', (e) => {
        e.preventDefault();
        imagePickerEl.click();
      });

      imagePickerEl.addEventListener('change', (e) => {
        const files = Array.from(e.target.files || []);
        files.forEach(file => {
          if (!file.type.startsWith('image/')) return;
          const previewUrl = URL.createObjectURL(file);
          const img = new Image();
          img.onload = () => {
            const aspect = img.naturalWidth && img.naturalHeight
              ? img.naturalWidth / img.naturalHeight
              : 1;
            createTopTile({
              shape: 'image',
              imageSrc: previewUrl,
              aspectRatio: aspect,
              text: '',
              textColor: 'light',
            });
          };
          img.src = previewUrl;
        });
        imagePickerEl.value = '';
      });
    }

    if (shareLinkButton) {
      shareLinkButton.addEventListener('click', (e) => {
        e.preventDefault();
        shareCurrentWorkspace();
      });
    }

    if (clearLinkButton) {
      clearLinkButton.addEventListener('click', (e) => {
        e.preventDefault();
        clearWorkspaceLink();
      });
    }

    if (singleUseToggle) {
      singleUseMode = singleUseToggle.checked;
      singleUseToggle.addEventListener('change', () => {
        singleUseMode = singleUseToggle.checked;
        clearSelection();
      });
    }

    document.addEventListener('click', (e) => {
      const selector = document.getElementById('colorSelector');
      const trigger = document.getElementById('addSquareButton');
      if (
        selector &&
        selector.style.display === 'block' &&
        !selector.contains(e.target) &&
        (!trigger || !trigger.contains(e.target))
      ) {
        selector.style.display = 'none';
      }
    });

    document.addEventListener('click', (e) => {
      if (!selectedElement) return;
      const inDropZone = Boolean(e.target.closest('.drop-zone'));
      const inTopShape = Boolean(e.target.closest('#topContainer .draggable-shape'));
      const inCircleTray = Boolean(e.target.closest('.circle'));
      const inMenu = Boolean(e.target.closest('#menuContent'));
      const inColorSelector = Boolean(e.target.closest('#colorSelector'));
      if (!inDropZone && !inTopShape && !inCircleTray && !inMenu && !inColorSelector) {
        clearSelection();
      }
    });

    function toggleLengthControls() {
      if (!shapeChoiceEl || !formLengthSelect || !lengthLabelEl) return;
      const show = shapeChoiceEl.value === 'strip';
      const displayValue = show ? 'block' : 'none';
      lengthLabelEl.style.display = displayValue;
      formLengthSelect.style.display = displayValue;
    }

    if (shapeChoiceEl && formLengthSelect && lengthLabelEl) {
      shapeChoiceEl.addEventListener('change', toggleLengthControls);
      toggleLengthControls();
    }

    document.querySelectorAll('#topContainer .draggable-shape').forEach(registerDraggableShape);

    function addNewTile() {
      const color = document.getElementById('colorChoice').value;
      const shape = document.getElementById('shapeChoice').value;
      const spanLength =
        shape === 'sentence'
          ? SENTENCE_SLOT_SPAN
          : shape === 'strip'
            ? clampStripSpan(formLengthSelect ? formLengthSelect.value : 2)
            : 1;
      createTopTile({
        shape,
        color,
        span: spanLength,
        text: '',
        textColor: 'light',
      });
      document.getElementById('colorSelector').style.display = 'none';
    }

    function encodeShareShape(value) {
      if (typeof value === 'number') return value;
      if (typeof value === 'string' && Object.prototype.hasOwnProperty.call(SHARE_SHAPE_LOOKUP, value)) {
        return SHARE_SHAPE_LOOKUP[value];
      }
      return value || 'square';
    }

    function decodeShareShape(value) {
      if (typeof value === 'number' && SHARE_SHAPE_KEYS[value]) {
        return SHARE_SHAPE_KEYS[value];
      }
      if (typeof value === 'string' && value.trim() !== '') {
        return value;
      }
      return 'square';
    }

    function encodeShareColor(value) {
      if (typeof value === 'number') return value;
      if (typeof value === 'string' && Object.prototype.hasOwnProperty.call(SHARE_COLOR_LOOKUP, value)) {
        return SHARE_COLOR_LOOKUP[value];
      }
      return value || 'red';
    }

    function decodeShareColor(value) {
      if (typeof value === 'number' && SHARE_COLOR_KEYS[value]) {
        return SHARE_COLOR_KEYS[value];
      }
      if (typeof value === 'string' && value.trim() !== '') {
        return value;
      }
      return 'red';
    }

    function encodeShareTextColor(value) {
      if (typeof value === 'number') return value;
      if (typeof value === 'string' && Object.prototype.hasOwnProperty.call(SHARE_TEXT_COLOR_LOOKUP, value)) {
        return SHARE_TEXT_COLOR_LOOKUP[value];
      }
      return value || 'light';
    }

    function decodeShareTextColor(value) {
      if (typeof value === 'number' && SHARE_TEXT_COLOR_KEYS[value]) {
        return SHARE_TEXT_COLOR_KEYS[value];
      }
      if (typeof value === 'string' && value.trim() !== '') {
        return value;
      }
      return 'light';
    }

    function compactPaletteEntry(tile) {
      if (!tile || typeof tile !== 'object') return tile;
      return [
        encodeShareShape(tile.shape),
        encodeShareColor(tile.color),
        encodeShareTextColor(tile.textColor),
        tile.span || 1,
        tile.text || '',
      ];
    }

    function expandPaletteEntry(entry) {
      if (Array.isArray(entry)) {
        const [shapeValue, colorValue, textColorValue, spanValue, textValue] = entry;
        return {
          shape: decodeShareShape(shapeValue),
          color: decodeShareColor(colorValue),
          textColor: decodeShareTextColor(textColorValue),
          span: typeof spanValue === 'number' ? spanValue : parseInt(spanValue, 10) || 1,
          text: typeof textValue === 'string' ? textValue : '',
        };
      }
      return entry;
    }

    function compactBoardTile(tile) {
      if (!tile || typeof tile !== 'object') return tile;
      const slotIndex = parseInt(tile.slot, 10);
      return [
        Number.isNaN(slotIndex) ? tile.slot : slotIndex,
        encodeShareShape(tile.shape),
        encodeShareColor(tile.color),
        encodeShareTextColor(tile.textColor),
        tile.span || 1,
        tile.text || '',
      ];
    }

    function expandBoardTile(entry) {
      if (Array.isArray(entry)) {
        const [slotValue, shapeValue, colorValue, textColorValue, spanValue, textValue] = entry;
        const slotIndex = parseInt(slotValue, 10);
        return {
          slot: Number.isNaN(slotIndex) ? 0 : slotIndex,
          shape: decodeShareShape(shapeValue),
          color: decodeShareColor(colorValue),
          textColor: decodeShareTextColor(textColorValue),
          span: typeof spanValue === 'number' ? spanValue : parseInt(spanValue, 10) || 1,
          text: typeof textValue === 'string' ? textValue : '',
        };
      }
      return entry;
    }

    function compactCircleEntry(circle) {
      if (!circle) return circle;
      if (typeof circle === 'number') return circle;
      if (typeof circle === 'object' && circle.slot !== undefined) {
        const slotIndex = parseInt(circle.slot, 10);
        return Number.isNaN(slotIndex) ? circle.slot : slotIndex;
      }
      const parsed = parseInt(circle, 10);
      return Number.isNaN(parsed) ? circle : parsed;
    }

    function expandCircleEntry(entry) {
      const slotIndex = typeof entry === 'number' ? entry : parseInt(entry, 10);
      if (Number.isNaN(slotIndex)) return null;
      return { slot: slotIndex };
    }

    function compactWorkspaceState(state) {
      if (!state || typeof state !== 'object') return state;
      const compact = { v: state.version || SHARE_STATE_VERSION };
      if (Array.isArray(state.palette) && state.palette.length) {
        compact.p = state.palette.map(compactPaletteEntry);
      }
      if (state.board && typeof state.board === 'object') {
        const board = {};
        if (Array.isArray(state.board.tiles) && state.board.tiles.length) {
          board.t = state.board.tiles.map(compactBoardTile);
        }
        if (Array.isArray(state.board.circles) && state.board.circles.length) {
          board.c = state.board.circles.map(compactCircleEntry);
        }
        if (Object.keys(board).length) {
          compact.b = board;
        }
      }
      return compact;
    }

    function expandWorkspaceState(raw) {
      if (Array.isArray(raw)) {
        return {
          version: SHARE_STATE_VERSION,
          palette: raw.map(expandPaletteEntry),
        };
      }
      if (!raw || typeof raw !== 'object') {
        return raw;
      }
      if (Array.isArray(raw.palette) || raw.board) {
        return raw;
      }
      const expanded = { version: raw.v || SHARE_STATE_VERSION };
      if (Array.isArray(raw.p)) {
        expanded.palette = raw.p.map(expandPaletteEntry);
      }
      if (raw.b && typeof raw.b === 'object') {
        const board = {};
        if (Array.isArray(raw.b.t)) {
          board.tiles = raw.b.t.map(expandBoardTile);
        }
        if (Array.isArray(raw.b.c)) {
          const entries = raw.b.c.map(expandCircleEntry).filter(Boolean);
          if (entries.length) {
            board.circles = entries;
          }
        }
        if (Object.keys(board).length) {
          if (!board.tiles) board.tiles = [];
          if (!board.circles) board.circles = [];
          expanded.board = board;
        }
      }
      if (!expanded.palette) {
        expanded.palette = [];
      }
      return expanded;
    }

    function exportPaletteState() {
      const tiles = Array.from(topContainer.querySelectorAll('.draggable-shape'));
      return tiles.map(tile => ({
        shape: tile.dataset.shape || 'square',
        color: tile.dataset.color || 'red',
        text: tile.dataset.text || '',
        span: parseInt(tile.dataset.span || '1', 10) || 1,
        textColor: tile.dataset.textColor || 'light',
        imageSrc: tile.dataset.imageSrc || '',
        imageAspect: tile.dataset.aspectRatio || '',
      }));
    }

    function applyPaletteConfig(configList) {
      if (!Array.isArray(configList)) return;
      topContainer.innerHTML = '';
      configList.forEach(entry => {
        if (!entry || typeof entry !== 'object') return;
        createTopTile({
          shape: typeof entry.shape === 'string' ? entry.shape : 'square',
          color: typeof entry.color === 'string' ? entry.color : 'red',
          text: typeof entry.text === 'string' ? entry.text : '',
          span: entry.span,
          textColor:
            typeof entry.textColor === 'string' && TEXT_COLORS[entry.textColor]
              ? entry.textColor
              : 'light',
          imageSrc: typeof entry.imageSrc === 'string' ? entry.imageSrc : '',
          aspectRatio: entry.imageAspect || entry.aspectRatio || null,
        });
      });
    }

    function exportDropZoneState() {
      const tileEntries = Array.from(dropZone.querySelectorAll('.dropped-shape'))
        .map(tile => {
          const baseSlot = tile.parentElement ? parseInt(tile.parentElement.dataset.index, 10) : NaN;
          if (Number.isNaN(baseSlot)) return null;
          return {
            slot: baseSlot,
            shape: tile.dataset.shape || 'square',
            color: tile.dataset.color || 'red',
            text: tile.dataset.text || '',
            textColor: tile.dataset.textColor || 'light',
            span: parseInt(tile.dataset.span || '1', 10) || 1,
            imageSrc: tile.dataset.imageSrc || '',
            imageAspect: tile.dataset.aspectRatio || '',
          };
        })
        .filter(Boolean)
        .sort((a, b) => a.slot - b.slot);

      const circleEntries = [];
      slots.forEach(slotEl => {
        const slotIndex = parseInt(slotEl.dataset.index, 10);
        if (Number.isNaN(slotIndex)) return;
        Array.from(slotEl.querySelectorAll('.circle')).forEach(circle => {
          if (circle.dataset.original === 'true') return;
          circleEntries.push({ slot: slotIndex });
        });
      });
      circleEntries.sort((a, b) => a.slot - b.slot);

      return { tiles: tileEntries, circles: circleEntries };
    }

    function clearDropZoneState() {
      Array.from(dropZone.querySelectorAll('.dropped-shape')).forEach(tile => removeTile(tile, false));
      slots.forEach(slotEl => {
        delete slotEl.dataset.occupantId;
        Array.from(slotEl.querySelectorAll('.circle')).forEach(circle => {
          if (circle.dataset.original === 'true') return;
          circle.remove();
        });
        layoutSlotCircles(slotEl);
      });
    }

    function addCircleFromConfig(slotIndex) {
      const slotEl = slots[slotIndex];
      if (!slotEl) return;
      const circleEl = createCircleCloneElement();
      if (!circleEl) return;
      const tile = getTileForSlot(slotEl);
      if (tile) {
        attachCircleToSlot(tile, circleEl, slotIndex);
        updateCirclePositions(tile);
      } else {
        slotEl.appendChild(circleEl);
        layoutSlotCircles(slotEl);
      }
    }

    function applyDropZoneConfig(boardConfig) {
      if (!boardConfig || typeof boardConfig !== 'object') return;
      clearDropZoneState();
      const tiles = Array.isArray(boardConfig.tiles) ? boardConfig.tiles : [];
      tiles.forEach(entry => {
        if (!entry || typeof entry !== 'object') return;
        const slotIndex = parseInt(entry.slot, 10);
        if (Number.isNaN(slotIndex)) return;
        const shape = typeof entry.shape === 'string' ? entry.shape : 'square';
        const color = typeof entry.color === 'string' ? entry.color : 'red';
        const text = typeof entry.text === 'string' ? entry.text : '';
        const textColor =
          typeof entry.textColor === 'string' && TEXT_COLORS[entry.textColor]
            ? entry.textColor
            : 'light';
        const span = entry.span;
        placeTileAtIndex(slotIndex, shape, color, text, textColor, span, {
          imageSrc: entry.imageSrc || '',
          imageAspect: entry.imageAspect || '',
        });
      });
      const circleEntries = Array.isArray(boardConfig.circles) ? boardConfig.circles : [];
      circleEntries.forEach(entry => {
        if (!entry || typeof entry !== 'object') return;
        const slotIndex = parseInt(entry.slot, 10);
        if (Number.isNaN(slotIndex)) return;
        addCircleFromConfig(slotIndex);
      });
    }

    function exportWorkspaceState() {
      return {
        version: SHARE_STATE_VERSION,
        palette: exportPaletteState(),
        board: exportDropZoneState(),
      };
    }

    function initWorkspaceFromUrl() {
      if (typeof URLSearchParams === 'undefined') return;
      const params = new URLSearchParams(window.location.search);
      const configParam = params.get('config');
      if (!configParam) return;
      const decodedState = decodeConfigPayload(configParam);
      if (decodedState) {
        if (Array.isArray(decodedState)) {
          applyPaletteConfig(decodedState);
          return;
        }
        if (decodedState && typeof decodedState === 'object') {
          if (Array.isArray(decodedState.palette)) {
            applyPaletteConfig(decodedState.palette);
          }
          if (decodedState.board) {
            applyDropZoneConfig(decodedState.board);
          }
        }
        return;
      }

      try {
        const parsed = JSON.parse(configParam);
        if (Array.isArray(parsed)) {
          applyPaletteConfig(parsed);
          return;
        }
        if (parsed && typeof parsed === 'object') {
          if (Array.isArray(parsed.palette)) {
            applyPaletteConfig(parsed.palette);
          }
          if (parsed.board) {
            applyDropZoneConfig(parsed.board);
          }
        }
      } catch (err) {
        console.error('Failed to parse palette config from URL', err);
      }
    }

    let shareButtonResetTimer = null;

    function getBaseWorkspaceUrl() {
      try {
        const url = new URL(window.location.href);
        url.hash = '';
        url.searchParams.delete('config');
        const remaining = url.searchParams.toString();
        url.search = remaining ? `?${remaining}` : '';
        return url.toString();
      } catch (err) {
        if (window.location.origin && window.location.origin !== 'null') {
          return `${window.location.origin}${window.location.pathname}`;
        }
        return window.location.href.split('#')[0].split('?')[0];
      }
    }

    const LZ_BASE64_KEY = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

    function lzCompress(input, bitsPerChar, getCharFromInt) {
      if (input == null) return '';
      let value;
      const context_dictionary = {};
      const context_dictionaryToCreate = {};
      let context_c = '';
      let context_wc = '';
      let context_w = '';
      let context_enlargeIn = 2;
      let context_dictSize = 3;
      let context_numBits = 2;
      let context_data = [];
      let context_data_val = 0;
      let context_data_position = 0;

      for (let ii = 0; ii < input.length; ii++) {
        context_c = input.charAt(ii);
        if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
          context_dictionary[context_c] = context_dictSize++;
          context_dictionaryToCreate[context_c] = true;
        }
        context_wc = context_w + context_c;
        if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
          context_w = context_wc;
        } else {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (let i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
              }
              value = context_w.charCodeAt(0);
              for (let i = 0; i < 8; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            } else {
              value = 1;
              for (let i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | value;
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (let i = 0; i < 16; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else {
                  context_data_position++;
                }
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn === 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (let i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position === bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn === 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          context_dictionary[context_wc] = context_dictSize++;
          context_w = String(context_c);
        }
      }

      if (context_w !== '') {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (let i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1);
              if (context_data_position === bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (let i = 0; i < 8; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position === bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (let i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1) | value;
              if (context_data_position === bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (let i = 0; i < 16; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position === bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn === 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (let i = 0; i < context_numBits; i++) {
            context_data_val = (context_data_val << 1) | (value & 1);
            if (context_data_position === bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn === 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
      }

      value = 2;
      for (let i = 0; i < context_numBits; i++) {
        context_data_val = (context_data_val << 1) | (value & 1);
        if (context_data_position === bitsPerChar - 1) {
          context_data_position = 0;
          context_data.push(getCharFromInt(context_data_val));
          context_data_val = 0;
        } else {
          context_data_position++;
        }
        value = value >> 1;
      }

      while (true) {
        context_data_val = (context_data_val << 1);
        if (context_data_position === bitsPerChar - 1) {
          context_data.push(getCharFromInt(context_data_val));
          break;
        }
        context_data_position++;
      }
      return context_data.join('');
    }

    function lzDecompress(length, resetValue, getNextValue) {
      const dictionary = [];
      let next;
      let enlargeIn = 4;
      let dictSize = 4;
      let numBits = 3;
      let entry = '';
      const result = [];
      let bits, resb, maxpower, power;
      let c;
      let data = { value: getNextValue(0), position: resetValue, index: 1 };

      for (let i = 0; i < 3; i++) {
        dictionary[i] = i;
      }

      const readBits = function (limit) {
        let bitsValue = 0;
        let powerValue = 1;
        while (powerValue !== limit) {
          if (data.position === 0) {
            data.position = resetValue;
            data.value = getNextValue(data.index++);
          }
          resb = data.value & data.position;
          data.position >>= 1;
          if (resb > 0) bitsValue |= powerValue;
          powerValue <<= 1;
        }
        return bitsValue;
      };

      bits = readBits(4);
      if (bits === 0) {
        c = readBits(1 << 8);
      } else if (bits === 1) {
        c = readBits(1 << 16);
      } else {
        return '';
      }
      dictionary[3] = String.fromCharCode(c);
      let w = String.fromCharCode(c);
      result.push(w);

      while (true) {
        if (data.index > length) {
          return result.join('');
        }
        const cc = readBits(1 << numBits);
        let code = cc;
        if (code === 0) {
          dictionary[dictSize++] = String.fromCharCode(readBits(1 << 8));
          code = dictSize - 1;
          enlargeIn--;
        } else if (code === 1) {
          dictionary[dictSize++] = String.fromCharCode(readBits(1 << 16));
          code = dictSize - 1;
          enlargeIn--;
        } else if (code === 2) {
          return result.join('');
        }

        if (enlargeIn === 0) {
          enlargeIn = Math.pow(2, numBits);
          numBits++;
        }

        if (dictionary[code]) {
          entry = dictionary[code];
        } else {
          if (code === dictSize) {
            entry = w + w.charAt(0);
          } else {
            return null;
          }
        }
        result.push(entry);

        dictionary[dictSize++] = w + entry.charAt(0);
        enlargeIn--;

        w = entry;

        if (enlargeIn === 0) {
          enlargeIn = Math.pow(2, numBits);
          numBits++;
        }
      }
    }

    function lzCompressToBase64(input) {
      if (input == null) return '';
      const res = lzCompress(input, 6, a => LZ_BASE64_KEY.charAt(a));
      switch (res.length % 4) {
        case 0:
          return res;
        case 1:
          return `${res}===`;
        case 2:
          return `${res}==`;
        case 3:
          return `${res}=`;
        default:
          return res;
      }
    }

    function lzDecompressFromBase64(input) {
      if (input == null) return '';
      if (input === '') return null;
      const sanitized = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
      return lzDecompress(sanitized.length, 32, index => LZ_BASE64_KEY.indexOf(sanitized.charAt(index)));
    }

    function encodeConfigPayload(state) {
      const shareReadyState = compactWorkspaceState(state);
      const json = JSON.stringify(shareReadyState);
      try {
        const compressed = lzCompressToBase64(json);
        if (compressed) {
          return compressed.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
        }
      } catch (err) {
        // ignore and fallback
      }
      if (typeof window.btoa === 'function') {
        try {
          const base64 = window.btoa(unescape(encodeURIComponent(json)));
          return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/g, '');
        } catch (err) {}
      }
      return encodeURIComponent(json);
    }

    function decodeConfigPayload(value) {
      if (!value || typeof value !== 'string') return null;
      try {
        const normalized = value.replace(/-/g, '+').replace(/_/g, '/');
        const decompressed = lzDecompressFromBase64(normalized);
        if (typeof decompressed === 'string' && decompressed.length) {
          return expandWorkspaceState(JSON.parse(decompressed));
        }
      } catch (err) {}

      if (typeof window.atob === 'function') {
        try {
          const normalized = value.replace(/-/g, '+').replace(/_/g, '/');
          const padLength = (4 - (normalized.length % 4)) % 4;
          const padded = normalized + '='.repeat(padLength);
          const json = decodeURIComponent(escape(window.atob(padded)));
          return expandWorkspaceState(JSON.parse(json));
        } catch (err) {}
      }
      try {
        const decoded = decodeURIComponent(value);
        return expandWorkspaceState(JSON.parse(decoded));
      } catch (err) {
        return null;
      }
    }

    function buildShareUrl(state) {
      const payload = encodeConfigPayload(state);
      try {
        const base = getBaseWorkspaceUrl();
        const url = new URL(base);
        url.searchParams.set('config', payload);
        return url.toString();
      } catch (err) {
        const base = getBaseWorkspaceUrl();
        const glue = base.includes('?') ? '&' : '?';
        return `${base}${glue}config=${encodeURIComponent(payload)}`;
      }
    }

    function showSharePrompt(link) {
      window.prompt('Shareable link', link);
    }

    function flashShareButton() {
      if (!shareLinkButton) return;
      if (!shareLinkButton.dataset.originalLabel) {
        shareLinkButton.dataset.originalLabel = shareLinkButton.textContent || 'Share';
      }
      shareLinkButton.textContent = 'Copied!';
      if (shareButtonResetTimer) {
        clearTimeout(shareButtonResetTimer);
      }
      shareButtonResetTimer = setTimeout(() => {
        shareLinkButton.textContent = shareLinkButton.dataset.originalLabel;
      }, 1500);
    }

    function shareCurrentWorkspace() {
      const state = exportWorkspaceState();
      const shareUrl = buildShareUrl(state);
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard
          .writeText(shareUrl)
          .then(() => {
            flashShareButton();
          })
          .catch(() => {
            showSharePrompt(shareUrl);
          });
      } else {
        showSharePrompt(shareUrl);
      }
    }

    function clearWorkspaceLink() {
      const cleanUrl = getBaseWorkspaceUrl();
      window.location.assign(cleanUrl);
    }

    dropZones.forEach((zoneEl, zoneIndex) => {
      for (let i = 0; i < SLOT_COUNT_PER_ZONE; i++) {
        const slotIndex = zoneIndex * SLOT_COUNT_PER_ZONE + i;
        const slot = document.createElement('div');
        slot.classList.add('slot');
        slot.dataset.index = slotIndex;

        slot.addEventListener('dragover', (e) => {
          e.preventDefault();
          const isCircleDrag =
            e.dataTransfer.getData('circle') ||
            (currentDragShape && currentDragShape.shape === 'circle');
          if (isCircleDrag) {
            clearSlotHighlights();
            return;
          }
        const slotIndexValue = parseInt(slot.dataset.index, 10);
        const shapeType =
          (currentDragShape && currentDragShape.shape) ||
          e.dataTransfer.getData('shape') ||
          '';
        const dragSpanData =
          (currentDragShape && currentDragShape.span) ||
          parseInt(e.dataTransfer.getData('span') || '', 10);
        const span = resolveShapeSpan(shapeType, dragSpanData);
        highlightSlotsFrom(slotIndexValue, span);
      });

      slot.addEventListener('mouseenter', () => {
        if (!selectedElement) return;
        const slotIndexValue = parseInt(slot.dataset.index, 10);
        const shapeType = selectedElement.type || '';
        const span = resolveShapeSpan(shapeType, selectedElement.span);
        highlightSlotsFrom(slotIndexValue, span);
      });

        slot.addEventListener('mouseleave', () => {
          if (!selectedElement) return;
          clearSlotHighlights();
        });



        slot.addEventListener('drop', (e) => {

  e.preventDefault();

  // If dragging a circle, don't process as a square drop
  const isCircleDrag =
    e.dataTransfer.getData('circle') ||
    (currentDragShape && currentDragShape.shape === 'circle');
  if (isCircleDrag) {
    clearSlotHighlights();
    currentDragShape = null;
    return;
  }

  const color = e.dataTransfer.getData('color') || e.dataTransfer.getData('move-color');
  const text = e.dataTransfer.getData('text') || '';
  const shapeType =
    (currentDragShape && currentDragShape.shape) ||
    e.dataTransfer.getData('shape') ||
    'square';
  const dragSpanData =
    (currentDragShape && currentDragShape.span) ||
    parseInt(e.dataTransfer.getData('span') || '', 10);
  const span = resolveShapeSpan(shapeType, dragSpanData);
  const textColor =
    e.dataTransfer.getData('text-color') ||
    (currentDragShape && currentDragShape.textColor) ||
    'light';
  const sourceSlot = e.dataTransfer.getData('source-slot');
  const paletteId = e.dataTransfer.getData('palette-id') || (currentDragShape && currentDragShape.paletteId) || '';
  const imageSrc =
    e.dataTransfer.getData('image-src') ||
    (currentDragShape && currentDragShape.imageSrc) ||
    '';
  const imageAspect =
    e.dataTransfer.getData('image-aspect') ||
    (currentDragShape && currentDragShape.aspectRatio) ||
    '';

  if (sourceSlot !== '') {
    const sourceSlotEl = document.querySelector(`.slot[data-index="${sourceSlot}"]`);
    if (sourceSlotEl && sourceSlotEl !== slot) {
      const movedShape = getTileForSlot(sourceSlotEl);
      if (movedShape) removeTile(movedShape, false);
    }
  }

  const slotIndexValue = parseInt(slot.dataset.index, 10);
  if (placeTileAtIndex(
    slotIndexValue,
    shapeType,
    color,
    text,
    textColor,
    span,
    { imageSrc, imageAspect }
  )) {
    dropSound.play();
    if (singleUseMode && paletteId) {
      removePaletteTileById(paletteId);
      clearSelection();
    }
  }

  clearSlotHighlights();
  currentDragShape = null;
});



        slot.addEventListener('click', () => {
  if (!selectedElement) return;
  const selection = { ...selectedElement };
  const slotIndex = parseInt(slot.dataset.index, 10);

  if (
    selection.type === 'square' ||
    selection.type === 'tower' ||
    selection.type === 'large-circle' ||
    selection.type === 'sentence' ||
    selection.type === 'strip' ||
    selection.type === 'image' ||
    MARK_SHAPES.has(selection.type)
  ) {
    if (placeTileAtIndex(
      slotIndex,
      selection.type,
      selection.color,
      selection.text,
      selection.textColor,
      selection.span,
      { imageSrc: selection.imageSrc || '', imageAspect: selection.aspectRatio || '' }
    )) {
      dropSound.play();
      if (singleUseMode && selection.sourceEl && selection.sourceEl.parentElement === topContainer) {
        removePaletteTileById(selection.paletteId || selection.sourceEl.dataset.paletteId || '');
      }
      clearSelection();
    }
    return;
  }
  if (selection.type === 'circle') {
  const droppedShape = getTileForSlot(slot);
  if (droppedShape && droppedShape.querySelectorAll('.circle').length >= maxCirclesForTile(droppedShape)) {
    return;
  }

  const original = document.querySelector(`.circle[data-id='${selection.id}']`);
  if (!original) return;

  const clone = original.cloneNode(true);
  const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
  clone.dataset.id = uniqueId;
  delete clone.dataset.original;

  clone.setAttribute('draggable', true);
  clone.style.position = 'absolute';

  clone.addEventListener('dragstart', (evt) => {
    currentDragShape = { shape: 'circle' };
    evt.dataTransfer.setData('circle', 'true');
    evt.dataTransfer.setData('circle-id', clone.dataset.id);
  });

  clone.addEventListener('click', () => removeCircleElement(clone));

  if (droppedShape) {
    attachCircleToSlot(droppedShape, clone, parseInt(slot.dataset.index, 10));
    updateCirclePositions(droppedShape);
  } else {
    const existingCircle = slot.querySelector('.circle');
    if (existingCircle) slot.removeChild(existingCircle);
    slot.appendChild(clone);
    layoutSlotCircles(slot);
  }

  clearSelection();
  return;
}

});
// !!!!!!!!!!!!!!!!!!!!!


        slot.addEventListener('touchmove', (e) => e.preventDefault());
        zoneEl.appendChild(slot);
        slots.push(slot);
      }
    });


document.body.addEventListener('drop', (e) => {
  clearSlotHighlights();
  currentDragShape = null;
  const isCircle = e.dataTransfer.getData('circle');
  const circleId = e.dataTransfer.getData('circle-id');

if (isCircle && circleId) {
  const draggedElement = document.querySelector(`.circle[data-id='${circleId}']`);

  // ðŸ›¡ Do NOT remove original circles
  if (
    draggedElement &&
    !e.target.closest('.dropped-shape') &&
    draggedElement.dataset.original !== 'true'
  ) {
    draggedElement.remove();
  }

  return;
}



  const sourceSlot = e.dataTransfer.getData('source-slot');
  if (sourceSlot !== '') {
    const sourceSlotEl = document.querySelector(`.slot[data-index="${sourceSlot}"]`);
    if (sourceSlotEl && !e.target.closest('.drop-zone')) {
      const draggedShape = getTileForSlot(sourceSlotEl);
      if (draggedShape) removeTile(draggedShape);
    }
  }
});


    




// Keep slot highlights tidy when dragging ends outside the drop zone
document.addEventListener('dragend', () => {
  clearSlotHighlights();
  currentDragShape = null;
});



    function toggleMenu() {
      const menu = document.getElementById('menuContent');
      menu.style.display = menu.style.display === 'block' ? 'none' : 'block';
    }

    function enableEditMode() {
      editMode = true;
      focusedEditableTile = null;
      if (editToolbar) {
        editToolbar.classList.add('active');
        updateTextColorMenuSelection(null);
      }
      document.querySelectorAll('#topContainer .draggable-shape').forEach(shape => makeEditableTop(shape));
    }

    function disableEditMode() {
      if (!editMode) return;
      editMode = false;
      focusedEditableTile = null;
      if (editToolbar) {
        editToolbar.classList.remove('active');
      }
      updateTextColorMenuSelection(null);
      document.querySelectorAll('#topContainer .draggable-shape input').forEach(input => {
        const parent = input.closest('.draggable-shape');
        if (!parent) return;
        const text = input.value;
        parent.textContent = text;
        parent.dataset.text = text;
        if (input.dataset.color) {
          parent.classList.add(input.dataset.color);
        }
        if ((parent.dataset.shape || 'square') === 'sentence') {
          parent.style.backgroundColor = resolveTileColor(parent.dataset.color || 'sentence');
        }
        applyTextColorToTile(parent, parent.dataset.textColor || 'light');
      });
      document
        .querySelectorAll('#topContainer .draggable-shape .delete-btn')
        .forEach(btn => btn.remove());
      document.querySelectorAll('#topContainer .draggable-shape').forEach(tile => {
        delete tile.dataset.editing;
        applyTextColorToTile(tile, tile.dataset.textColor || 'light');
        if (MARK_SHAPES.has(tile.dataset.shape || '')) {
          const symbol = tile.dataset.text || getMarkSymbol(tile.dataset.shape || '');
          let span = tile.querySelector('span');
          if (!span) {
            span = document.createElement('span');
            tile.appendChild(span);
          }
          span.textContent = symbol;
        }
      });
    }



    function makeEditableTop(tile) {
      if (tile.dataset.editing === 'true') return;
      tile.dataset.editing = 'true';
      const shapeType = tile.dataset.shape || 'square';
      const isMarkShape = MARK_SHAPES.has(shapeType);
      const currentText = tile.dataset.text || tile.textContent || '';
      const colorClass = tile.dataset.color || '';

      let inputEl = null;
      if (!isMarkShape) {
        tile.innerHTML = '';
        inputEl = document.createElement('input');
        inputEl.type = 'text';
        inputEl.value = currentText;
        inputEl.dataset.color = colorClass;
        tile.appendChild(inputEl);
        inputEl.focus();
        inputEl.style.color = resolveTextColor(tile.dataset.textColor || 'light');
        inputEl.addEventListener('focus', () => setFocusedEditableTile(tile));
        inputEl.addEventListener('click', (event) => {
          event.stopPropagation();
          setFocusedEditableTile(tile);
        });
        inputEl.addEventListener('mousedown', (event) => {
          event.stopPropagation();
        });
        inputEl.addEventListener('input', () => {
          tile.dataset.text = inputEl.value;
        });
      } else {
        const symbol = getMarkSymbol(shapeType) || currentText;
        tile.textContent = '';
        const span = document.createElement('span');
        span.textContent = symbol;
        tile.appendChild(span);
        tile.dataset.text = symbol;
        if (!tile.dataset.markEditListener) {
          tile.addEventListener('click', () => setFocusedEditableTile(null));
          tile.dataset.markEditListener = 'true';
        }
      }

      const deleteBtn = document.createElement('button');
      deleteBtn.className = 'delete-btn';
      deleteBtn.textContent = 'x';
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteSound.play();
        topContainer.removeChild(tile);
        if (focusedEditableTile === tile) {
          setFocusedEditableTile(null);
        }
      });
      tile.appendChild(deleteBtn);
    }

    function createDropShape(
      shapeType,
      color,
      text = '',
      spanOverride = 1,
      textColor = 'light',
      extra = {}
    ) {
      const normalizedShape = shapeType || 'square';
      const tile = document.createElement('div');
      tile.classList.add('dropped-shape');
      const colorKey = color || (normalizedShape === 'sentence' ? 'sentence' : 'red');
      tile.dataset.color = colorKey;
      tile.dataset.shape = normalizedShape;
      tile.dataset.text = text;
      tile.setAttribute('draggable', true);
      tile.textContent = text;
      tile.dataset.tileId = generateTileId();
      const resolvedSpan = resolveShapeSpan(normalizedShape, spanOverride);
      tile.dataset.span = resolvedSpan;
      tile.dataset.textColor = textColor || 'light';
      applyTextColorToTile(tile, tile.dataset.textColor);

      if (MARK_SHAPES.has(normalizedShape)) {
        const symbol = getMarkSymbol(normalizedShape);
        tile.classList.add('dropped-mark', 'mark', normalizedShape);
        tile.dataset.text = symbol;
        tile.innerHTML = `<span>${symbol}</span>`;
        tile.style.backgroundColor = 'transparent';
        tile.style.color = resolveTileColor(colorKey);
      } else if (MULTI_SLOT_SHAPES.has(normalizedShape)) {
        if (normalizedShape === 'sentence') {
          tile.classList.add('dropped-sentence');
        } else if (normalizedShape === 'strip') {
          tile.classList.add('dropped-strip');
          applyStripDimensions(tile, resolvedSpan);
        }
        tile.style.backgroundColor = resolveTileColor(colorKey);
      } else if (normalizedShape === 'large-circle') {
        tile.classList.add('dropped-large-circle');
        tile.style.backgroundColor = resolveTileColor(colorKey);
      } else if (normalizedShape === 'tower') {
        tile.classList.add('dropped-tower');
        tile.style.backgroundColor = resolveTileColor(colorKey);
      } else if (normalizedShape === 'image') {
        tile.classList.add('dropped-image');
        const aspect = parseFloat(extra.imageAspect) || parseFloat(tile.dataset.aspectRatio) || 1;
        tile.dataset.aspectRatio = aspect;
        tile.dataset.imageSrc = extra.imageSrc || tile.dataset.imageSrc || '';
        applyImageDimensions(tile, aspect);
        if (tile.dataset.imageSrc) {
          tile.style.backgroundImage = `url('${tile.dataset.imageSrc}')`;
        }
        tile.style.backgroundColor = '#ccc';
      } else {
        tile.classList.add('dropped-square');
        tile.style.backgroundColor = resolveTileColor(colorKey);
      }

      tile.addEventListener('dblclick', () => removeTile(tile));

      tile.addEventListener('dragstart', (ev) => {
        const spanValue = parseInt(tile.dataset.span || '1', 10) || 1;
        const textColorValue = tile.dataset.textColor || 'light';
        currentDragShape = {
          shape: normalizedShape,
          span: spanValue,
          textColor: textColorValue,
          imageSrc: tile.dataset.imageSrc || '',
          aspectRatio: tile.dataset.aspectRatio || '',
        };
        applyDragPreview(tile, ev);
        const draggedText = tile.textContent || tile.dataset.text || '';
        ev.dataTransfer.setData('move-color', tile.dataset.color);
        ev.dataTransfer.setData('text', draggedText);
        ev.dataTransfer.setData('source-slot', tile.parentElement.dataset.index);
        ev.dataTransfer.setData('shape', normalizedShape);
        ev.dataTransfer.setData('span', spanValue.toString());
        ev.dataTransfer.setData('text-color', textColorValue);
        if (tile.dataset.imageSrc) {
          ev.dataTransfer.setData('image-src', tile.dataset.imageSrc);
        }
        if (tile.dataset.aspectRatio) {
          ev.dataTransfer.setData('image-aspect', tile.dataset.aspectRatio);
        }
      });

      return tile;
    }

    function placeTileAtIndex(
      slotIndex,
      shapeType,
      color,
      text,
      textColor = 'light',
      spanOverride = null,
      extra = {}
    ) {
      let span = resolveShapeSpan(shapeType, spanOverride);
      if (shapeType === 'image') {
        const aspectForSpan = parseFloat(extra.imageAspect) || parseFloat(extra.aspectRatio) || null;
        if (aspectForSpan) {
          span = computeImageSpan(aspectForSpan);
        }
      }
      if (slotIndex + span > slots.length) return false;

      const occupiedIds = new Set();
      for (let i = 0; i < span; i++) {
        const slot = slots[slotIndex + i];
        if (!slot) return false;
        if (slot.dataset.occupantId) {
          occupiedIds.add(slot.dataset.occupantId);
        }
      }

      occupiedIds.forEach(removeTileById);

      const baseSlot = slots[slotIndex];
      const existingTile = getTileForSlot(baseSlot);
      if (existingTile) removeTile(existingTile, false);

      const newShape = createDropShape(shapeType, color, text, span, textColor, extra);
      baseSlot.appendChild(newShape);
      occupySlots(slotIndex, span, newShape.dataset.tileId);
      if (span > 1) {
        for (let i = 0; i < span; i++) {
          layoutSlotCircles(slots[slotIndex + i]);
        }
      } else {
        layoutSlotCircles(baseSlot);
      }
      return true;
    }

    function getTileForSlot(slot) {
      if (!slot) return null;
      const direct = slot.querySelector('.dropped-shape');
      if (direct) return direct;
      const occupantId = slot.dataset.occupantId;
      if (!occupantId) return null;
      return dropZone.querySelector(`.dropped-shape[data-tile-id='${occupantId}']`);
    }

    function occupySlots(startIndex, span, tileId) {
      for (let i = 0; i < span; i++) {
        const slot = slots[startIndex + i];
        if (slot) slot.dataset.occupantId = tileId;
      }
    }

    function clearSlotOccupancy(startIndex, span, tileId) {
      for (let i = 0; i < span; i++) {
        const slot = slots[startIndex + i];
        if (slot && slot.dataset.occupantId === tileId) {
          delete slot.dataset.occupantId;
          Array.from(slot.querySelectorAll('.circle')).forEach(circle => circle.remove());
          layoutSlotCircles(slot);
        }
      }
    }

    function removeTileById(tileId) {
      if (!tileId) return;
      const tile = dropZone.querySelector(`.dropped-shape[data-tile-id='${tileId}']`);
      if (tile) removeTile(tile, false);
    }

    function removeTile(tile, playSound = true) {
      const startIndex = parseInt(tile.parentElement.dataset.index, 10);
      const span = parseInt(tile.dataset.span || '1', 10);
      const tileId = tile.dataset.tileId;
      clearSlotOccupancy(startIndex, span, tileId);
      tile.parentElement.removeChild(tile);
      if (playSound) deleteSound.play();
    }

    function removePaletteTileById(paletteId) {
      if (!paletteId) return;
      const paletteTile = topContainer.querySelector(`.draggable-shape[data-palette-id='${paletteId}']`);
      if (paletteTile) {
        paletteTile.remove();
      }
    }

    function generateTileId() {
      return 'tile-' + Math.random().toString(36).substr(2, 9);
    }

    function attachCircleToSlot(tileEl, circleEl, slotIndex) {
      const baseIndex = parseInt(tileEl.parentElement.dataset.index, 10);
      if (Number.isNaN(baseIndex)) {
        circleEl.dataset.attachedSlot = '';
        return baseIndex;
      }

      const isSentence = tileEl.classList.contains('dropped-sentence');
      const span = parseInt(
        tileEl.dataset.span || (isSentence ? SENTENCE_SLOT_SPAN : '1'),
        10
      ) || 1;
      const minIndex = baseIndex;
      const maxIndex = baseIndex + span - 1;
      let assigned = typeof slotIndex === 'number' && !Number.isNaN(slotIndex)
        ? slotIndex
        : baseIndex;
      assigned = Math.max(minIndex, Math.min(maxIndex, assigned));

      const counts = new Map();
      for (let i = 0; i < span; i++) {
        const slot = slots[minIndex + i];
        if (!slot) continue;
        Array.from(slot.querySelectorAll('.circle'))
          .filter(c => c !== circleEl)
          .forEach(c => {
            const idx = Math.max(minIndex, Math.min(maxIndex, parseInt(c.dataset.attachedSlot || (minIndex + i), 10)));
            if (!Number.isNaN(idx)) {
              counts.set(idx, (counts.get(idx) || 0) + 1);
            }
          });
      }

      const capacityPerSlot = 3;
      if ((counts.get(assigned) || 0) >= capacityPerSlot) {
        for (let offset = 1; offset <= span; offset++) {
          const forward = assigned + offset;
          if (forward <= maxIndex && (counts.get(forward) || 0) < capacityPerSlot) {
            assigned = forward;
            break;
          }
          const backward = assigned - offset;
          if (backward >= minIndex && (counts.get(backward) || 0) < capacityPerSlot) {
            assigned = backward;
            break;
          }
        }
      }

      const slotEl = slots[assigned];
      if (slotEl) {
        circleEl.dataset.attachedSlot = assigned;
        circleEl.dataset.parentTile = tileEl.dataset.tileId || '';
        if (circleEl.parentElement !== slotEl) {
          slotEl.appendChild(circleEl);
        }
        layoutSlotCircles(slotEl);
      }
      return assigned;
    }

    function computeMultiSlotIndex(tileEl, clientX) {
      if (!tileEl) return 0;
      const parentSlot = tileEl.parentElement;
      const baseIndex = parentSlot ? parseInt(parentSlot.dataset.index, 10) : NaN;
      if (Number.isNaN(baseIndex)) return 0;
      const span = parseInt(
        tileEl.dataset.span || (tileEl.classList.contains('dropped-sentence') ? SENTENCE_SLOT_SPAN : '1'),
        10
      ) || 1;
      if (span <= 1) {
        return baseIndex;
      }

      let closestIndex = baseIndex;
      let minDist = Infinity;
      for (let i = 0; i < span; i++) {
        const slot = slots[baseIndex + i];
        if (!slot) continue;
        const rect = slot.getBoundingClientRect();
        const center = rect.left + rect.width / 2;
        const dist = Math.abs(center - clientX);
        if (dist < minDist) {
          minDist = dist;
          closestIndex = baseIndex + i;
        }
      }
      return closestIndex;
    }

    function slotFromPoint(x, y) {
      for (const slot of slots) {
        const rect = slot.getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          return slot;
        }
      }
      return null;
    }

    function maxCirclesForTile(tileEl) {
      if (!tileEl) return 3;
      const span = parseInt(
        tileEl.dataset.span || (tileEl.classList.contains('dropped-sentence') ? SENTENCE_SLOT_SPAN : '1'),
        10
      ) || 1;
      return span * 3;
    }

    function removeCircleElement(circleEl) {
      if (!circleEl || circleEl.dataset.original === 'true') return;
      const slotEl = circleEl.parentElement;
      circleEl.remove();
      if (slotEl) {
        layoutSlotCircles(slotEl);
        const tile = getTileForSlot(slotEl);
        if (tile) updateCirclePositions(tile);
      }
      deleteSound.play();
      clearSelection();
    }

    function createCircleCloneElement() {
      const template = circleTemplate || document.querySelector('.circle[data-original="true"]');
      if (!template) return null;
      const clone = template.cloneNode(true);
      const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
      clone.dataset.id = uniqueId;
      delete clone.dataset.original;
      clone.setAttribute('draggable', true);
      clone.style.position = 'absolute';
      clone.addEventListener('dragstart', (e) => {
        currentDragShape = { shape: 'circle' };
        e.dataTransfer.setData('circle', 'true');
        e.dataTransfer.setData('circle-id', clone.dataset.id);
      });
      clone.addEventListener('click', () => removeCircleElement(clone));
      return clone;
    }

    function applyDragPreview(element, event) {
      if (!event.dataTransfer) return;
      const rect = element.getBoundingClientRect();
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(rect.width));
      canvas.height = Math.max(1, Math.round(rect.height));
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const styles = window.getComputedStyle(element);
      ctx.fillStyle = styles.backgroundColor;

      if (element.classList.contains('sentence') || element.classList.contains('dropped-sentence')) {
        const rootStyles = getComputedStyle(document.documentElement);
        const armWidthPx = parseFloat(rootStyles.getPropertyValue('--sentence-arm-width')) || rect.width * 0.2;
        const sentenceWidthPx = parseFloat(rootStyles.getPropertyValue('--sentence-width')) || rect.width;
        const armHeightPx = parseFloat(rootStyles.getPropertyValue('--square-size')) || rect.height / 2;
        const sentenceHeightPx = parseFloat(rootStyles.getPropertyValue('--sentence-height')) || rect.height;
        const armWidth = rect.width * (armWidthPx / sentenceWidthPx);
        const armHeight = rect.height * (armHeightPx / sentenceHeightPx);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(armWidth, 0);
        ctx.lineTo(armWidth, armHeight);
        ctx.lineTo(rect.width, armHeight);
        ctx.lineTo(rect.width, rect.height);
        ctx.lineTo(0, rect.height);
        ctx.closePath();
        ctx.fill();
      } else if (element.classList.contains('large-circle') || element.classList.contains('dropped-large-circle')) {
        ctx.beginPath();
        ctx.arc(rect.width / 2, rect.height / 2, Math.min(rect.width, rect.height) / 2, 0, Math.PI * 2);
        ctx.fill();
      } else if (element.classList.contains('image-tile') || element.classList.contains('dropped-image')) {
        ctx.fillStyle = styles.backgroundColor || '#ccc';
        ctx.fillRect(0, 0, rect.width, rect.height);
        ctx.fillStyle = 'rgba(0,0,0,0.35)';
        ctx.fillRect(0, rect.height - BASE_TILE_SIZE, rect.width, BASE_TILE_SIZE);
        ctx.fillStyle = '#fff';
        ctx.font = `700 ${Math.max(14, rect.height * 0.25)}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('IMG', rect.width / 2, rect.height / 2);
      } else if (element.classList.contains('mark') || element.classList.contains('dropped-mark')) {
        const glyphEl = element.querySelector('span') || element;
        const glyphStyles = window.getComputedStyle(glyphEl);
        const symbol =
          (element.dataset.text && element.dataset.text.trim()) ||
          (glyphEl.textContent && glyphEl.textContent.trim()) ||
          getMarkSymbol(element.dataset.shape || '') ||
          '!';
        const fontFamily = glyphStyles.fontFamily || styles.fontFamily || 'sans-serif';
        const fontWeight = glyphStyles.fontWeight || styles.fontWeight || '600';
        const fontSize = glyphStyles.fontSize || `${rect.height * 0.8}px`;
        ctx.fillStyle = glyphStyles.color || '#111';
        ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'bottom';
        ctx.fillText(symbol, rect.width / 2, rect.height);
      } else {
        ctx.fillRect(0, 0, rect.width, rect.height);
      }

      const text = (element.textContent || '').trim();
      if (text) {
        ctx.fillStyle = styles.color;
        ctx.font = `${styles.fontWeight} ${styles.fontSize} ${styles.fontFamily}`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const isTower =
          (element.dataset && element.dataset.shape === 'tower') ||
          element.classList.contains('tower') ||
          element.classList.contains('dropped-tower');
        const isSentence =
          (element.dataset && element.dataset.shape === 'sentence') ||
          element.classList.contains('sentence') ||
          element.classList.contains('dropped-sentence');
        const isImage =
          (element.dataset && element.dataset.shape === 'image') ||
          element.classList.contains('image-tile') ||
          element.classList.contains('dropped-image');
        const textY = isTower || isSentence || isImage ? rect.height - BASE_TILE_SIZE / 2 : rect.height / 2;
        ctx.fillText(text, rect.width / 2, textY, rect.width - 10);
      }

      const offsetX = event.clientX - rect.left;
      const offsetY = event.clientY - rect.top;
      event.dataTransfer.setDragImage(canvas, offsetX, offsetY);
      // Safari/WebKit needs the canvas kept in DOM until drag ends
      canvas.style.position = 'fixed';
      canvas.style.top = '-9999px';
      canvas.style.left = '-9999px';
      document.body.appendChild(canvas);
      setTimeout(() => {
        if (canvas.parentElement) canvas.parentElement.removeChild(canvas);
      }, 0);
    }

    // Handle drop outside of drop-zone to delete square
    document.body.addEventListener('dragover', (e) => e.preventDefault());




document.querySelectorAll('.circle').forEach(circle => {
  circle.addEventListener('click', () => {
    if (!circle.dataset.original) {
      removeCircleElement(circle);
      return;
    }

    selectedElement = {
      type: 'circle',
      id: circle.dataset.id,
    };

    // Visual feedback
    document.querySelectorAll('.circle').forEach(c => c.classList.remove('selected'));
    circle.classList.add('selected');
  });

  circle.addEventListener('dragstart', (e) => {
    const id = circle.dataset.id || Math.random().toString(36).substr(2, 9);
    circle.dataset.id = id;
    currentDragShape = { shape: 'circle' };
    e.dataTransfer.setData('circle', 'true');
    e.dataTransfer.setData('circle-id', id);
  });
});





function updateCirclePositions(tileEl) {
  if (!tileEl) return;
  const parentSlot = tileEl.parentElement;
  const baseIndex = parentSlot ? parseInt(parentSlot.dataset.index, 10) : NaN;
  const span = parseInt(
    tileEl.dataset.span || (tileEl.classList.contains('dropped-sentence') ? SENTENCE_SLOT_SPAN : '1'),
    10
  ) || 1;
  if (!Number.isNaN(baseIndex) && span > 1) {
    for (let i = 0; i < span; i++) {
      layoutSlotCircles(slots[baseIndex + i]);
    }
    return;
  }
  if (parentSlot) {
    layoutSlotCircles(parentSlot);
  }
}



function clearSelection() {
  selectedElement = null;
  document.querySelectorAll('.draggable-shape.selected, .circle.selected')
    .forEach(el => el.classList.remove('selected'));
  clearSlotHighlights();
}




// Ð”Ð¾Ð±Ð°Ð²Ð¸Ð¼ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸Ðº Ð¿Ñ€ÑÐ¼Ð¾ Ð½Ð° dropZone Ð´Ð»Ñ Ð´ÐµÐ»ÐµÐ³Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ
dropZone.addEventListener('drop', (e) => {
  const isCircle = e.dataTransfer.getData('circle');
  if (!isCircle) return;

  const pointerSlot = slotFromPoint(e.clientX, e.clientY);
  let targetShape = pointerSlot ? getTileForSlot(pointerSlot) : null;
  if (!targetShape) {
    const elem = document.elementFromPoint(e.clientX, e.clientY);
    targetShape = elem ? elem.closest('.dropped-shape') : null;
  }
  if (targetShape) {
    e.stopImmediatePropagation(); // ðŸ›‘ 
    if (targetShape.querySelectorAll('.circle').length >= maxCirclesForTile(targetShape)) {
      return;
    }

    const circleId = e.dataTransfer.getData('circle-id');
    const original = document.querySelector(`.circle[data-id='${circleId}']`);
    if (!original) return;

    const clone = original.cloneNode(true);
    const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
    clone.dataset.id = uniqueId;
    delete clone.dataset.original;

    clone.setAttribute('draggable', true);
    clone.style.position = 'absolute';

    clone.addEventListener('dragstart', (e) => {
      currentDragShape = { shape: 'circle' };
      e.dataTransfer.setData('circle', 'true');
      e.dataTransfer.setData('circle-id', clone.dataset.id);
    });

    clone.addEventListener('click', () => removeCircleElement(clone));

    targetShape.appendChild(clone);
    const slotIndex = pointerSlot
      ? parseInt(pointerSlot.dataset.index, 10)
      : targetShape.classList.contains('dropped-sentence') || targetShape.classList.contains('dropped-strip')
        ? computeMultiSlotIndex(targetShape, e.clientX)
        : parseInt(targetShape.parentElement.dataset.index, 10);
    attachCircleToSlot(targetShape, clone, slotIndex);
    updateCirclePositions(targetShape);
    currentDragShape = null;
  }
});




dropZone.addEventListener('drop', (e) => {
  e.preventDefault();

  const isCircle = e.dataTransfer.getData('circle');
  const circleId = e.dataTransfer.getData('circle-id');
  if (!isCircle || !circleId) return;

  const original = document.querySelector(`.circle[data-id='${circleId}']`);
  if (!original) return;

  const pointerSlot = slotFromPoint(e.clientX, e.clientY);
  if (pointerSlot && !getTileForSlot(pointerSlot)) {
    const clone = original.cloneNode(true);
    const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
    clone.dataset.id = uniqueId;
    delete clone.dataset.original;

    clone.setAttribute('draggable', true);
    clone.style.position = 'absolute';

    clone.addEventListener('dragstart', (evt) => {
      currentDragShape = { shape: 'circle' };
      evt.dataTransfer.setData('circle', 'true');
      evt.dataTransfer.setData('circle-id', clone.dataset.id);
    });

    clone.addEventListener('click', () => removeCircleElement(clone));

    const existingCircle = pointerSlot.querySelector('.circle');
    if (existingCircle) pointerSlot.removeChild(existingCircle);
    pointerSlot.appendChild(clone);
    layoutSlotCircles(pointerSlot);
    clearSelection();
    currentDragShape = null;
    return;
  }

  const slotList = slots;

  // ÐÐ°Ð¹Ñ‚Ð¸ Ð¸Ð½Ð´ÐµÐºÑ ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð¿Ñ€Ð°Ð²Ð¾Ð³Ð¾ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¸ÐºÐ°
  let lastSquareIndex = -1;
  slotList.forEach((slot, index) => {
    if (getTileForSlot(slot)) {
      lastSquareIndex = index;
    }
  });

  // Ð•ÑÐ»Ð¸ Ð½ÐµÑ‚ Ð½Ð¸ Ð¾Ð´Ð½Ð¾Ð³Ð¾ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¸ÐºÐ° â€” Ð½Ðµ Ñ€Ð°Ð·Ñ€ÐµÑˆÐ°ÐµÐ¼
  if (lastSquareIndex === -1) return;

  // ÐÐ°Ð¹Ñ‚Ð¸ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ Ð´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ð¹ ÑÐ»Ð¾Ñ‚ ÑÐ¿Ñ€Ð°Ð²Ð° Ð¾Ñ‚ ÑÐ°Ð¼Ð¾Ð³Ð¾ Ð¿Ñ€Ð°Ð²Ð¾Ð³Ð¾ ÐºÐ²Ð°Ð´Ñ€Ð°Ñ‚Ð¸ÐºÐ°
 


  let targetSlot = null;
  for (let i = lastSquareIndex + 1; i < slotList.length; i++) {
    if (!getTileForSlot(slotList[i])) {
      // ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼, Ñ‡Ñ‚Ð¾ Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰Ð¸Ðµ Ð¼ÐµÐ¶Ð´Ñƒ lastSquareIndex Ð¸ i â€” Ð²ÑÐµ Ð·Ð°Ð½ÑÑ‚Ñ‹
      const hasGap = slotList.slice(lastSquareIndex + 1, i).some(s => !getTileForSlot(s));
      if (!hasGap) {
        targetSlot = slotList[i];
        break;
      }
    }
  }










  if (!targetSlot) return;

  // ÐšÐ»Ð¾Ð½Ð¸Ñ€ÑƒÐµÐ¼ ÐºÑ€ÑƒÐ¶Ð¾Ðº
  const clone = original.cloneNode(true);
  const uniqueId = 'clone-' + Math.random().toString(36).substr(2, 9);
  clone.dataset.id = uniqueId;
  delete clone.dataset.original;

  clone.setAttribute('draggable', true);
  clone.style.position = 'absolute';

//  clone.addEventListener('dragstart', (e) => {
//    e.dataTransfer.setData('circle', 'true');
//    e.dataTransfer.setData('circle-id', clone.dataset.id);
//  });

  
clone.addEventListener('dragstart', (e) => {
  currentDragShape = { shape: 'circle' };
  e.dataTransfer.setData('circle', 'true');
  e.dataTransfer.setData('circle-id', clone.dataset.id);
});

clone.addEventListener('click', () => {
  removeCircleElement(clone);
});


  const existingCircle = targetSlot.querySelector('.circle');
  if (existingCircle) targetSlot.removeChild(existingCircle);
    targetSlot.appendChild(clone);
    layoutSlotCircles(targetSlot);
    clearSelection();
    currentDragShape = null;
});

//if (isMobile) {
  dropZone.addEventListener('click', (e) => {
    const circle = e.target.closest('.circle');
    if (circle && !circle.dataset.original) {
      removeCircleElement(circle);
      return;
    }

    const tile = e.target.closest('.dropped-shape');
    if (tile && dropZone.contains(tile)) {
      const baseSlot = tile.parentElement;
      const baseIndex = baseSlot ? parseInt(baseSlot.dataset.index, 10) : NaN;
      const span = parseInt(tile.dataset.span || '1', 10);
      let hasCircles = false;

      if (!Number.isNaN(baseIndex)) {
        for (let i = 0; i < span; i++) {
          const slotEl = slots[baseIndex + i];
          if (slotEl && slotEl.querySelector('.circle')) {
            hasCircles = true;
            break;
          }
        }
      }

      if (!hasCircles) {
        removeTile(tile);
        clearSelection(); // Ensure no lingering selections
      }
    }

  });
//}






    initWorkspaceFromUrl();
  </script>
</body>
</html>
